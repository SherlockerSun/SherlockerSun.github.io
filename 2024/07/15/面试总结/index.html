<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>面试总结 | SherlockerSun</title><meta name="keywords" content="Java"><meta name="author" content="SherlockerSun"><meta name="copyright" content="SherlockerSun"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="面试总结"><meta name="application-name" content="面试总结"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="面试总结"><meta property="og:url" content="http://example.com/2024/07/15/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/index.html"><meta property="og:site_name" content="SherlockerSun"><meta property="og:description" content="Java 基础1、Java的基本数据类型有哪些，占几个字节八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。  整型：byte、short、int、long 浮点型：float、double 字符型：char 布尔型：boolean     序号 数据类型 位数 字"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="SherlockerSun"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="Java 基础1、Java的基本数据类型有哪些，占几个字节八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。  整型：byte、short、int、long 浮点型：float、double 字符型：char 布尔型：boolean     序号 数据类型 位数 字"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2024/07/15/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: SherlockerSun","link":"链接: ","source":"来源: SherlockerSun","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'SherlockerSun',
  title: '面试总结',
  postAI: '',
  pageFillDescription: 'Java 基础, 1、Java的基本数据类型有哪些占几个字节, 2、String类型比较, 3、AOP是什么有用过哪里, 4、HashMap 原理线程安全吗, 1.HashMap原理, 2.HashMap扩容机制, 3.ConcurrentHashMap底层原理, 4.ConcurrentHashMap和HashMap, 5.HashMap和HashTable的区别, 6.hashtable和concurrenthashmap, 7.CountDownLatch, 5、ArrayList和LinkedList区别, 6、@Transactional（rollbackx3DException. class）有没有可能会失效不加 rollback 会怎么样, 7、SpringMVC 流程, 8、BIO、NIO、AIO, 高并发, 1、线程的生命周期和状态, 1. 线程的生命周期包含 5 个阶段：新建、就绪、运行、阻塞、销毁, 2. 线程的 6 个状态：, 3. 阻塞的三种情况：等待阻塞、同步阻塞、其他阻塞, sleep 和 wait 的区别：, 4. 线程死亡的三种情况：, 2、创建线程的三种方式线程池的好处, 1. 创建线程的三种方式：1 个继承两个实现, 2. 使用线程池的好处, 3、如何创建线程池, 1. 通过构造方法实现, 2. 通过 Executor 框架的工具类 Executors 来实现, 4、submit 和 execute 的区别, 5、Java 并发包下常用的类库, 6、Nacos、ZooKeeper、Eureka 的选择各种优缺点, 7、AQS, 1. AQS 核心思想, 2. CLH, 3. 什么是钩子方法, 8、CAS, 9、BlockingQueue, 10、lock, 1. 锁（Lock）, 2. 互斥锁（Mutex Lock）, 3. 自旋锁（Spin Lock）, 11、volatile, 12、synchronized, 微服务, 1、微服务事务解决方案 2 PC、ttc 等, 1. 2 PC, 2. TTC：, 2、CAP、BASE 理论在项目中的取舍, 1. CAP 定理, 2. BASE 理论, 数据库, 1、MySQL存储引擎有哪些默认的存储引擎是什么为什么用这个, 1.InnoDB存储引擎, 2.MyISAM存储引擎, 3.MEMORY存储引擎, 4.MERGE存储引擎, 5.默认的存储引擎, 6.MyISAM和InnoDB的区别, 2、数据库事务特性事务的隔离级别, 3、索引的优缺点组合索引特性, 4、外联接和内联接的区别, 5、索引失效场景及原理, 6、MySQL 全文索引, 7、SQL 关键字实际执行顺序, JVM, 1、JVM 的内存结构, 2、JVM常用参数, 3、JVM常用工具, 4、JVM类加载机制, 5、类加载器有哪些, 6、双亲委派是什么, 7、垃圾回收算法常用的有哪些, 8、Java常见的几种垃圾收集器Java8默认的垃圾收集器是什么, 1.常见的几种, 1.Serial收集器：, 2.Serial Old收集器：, 3.Parale Scavenge收集器：, 4.Parallel Old收集器：, 5.ParNew收集器：, 6.CMS(Concurrent Mark Sweep) 收集器, 7.G1收集器：, 2.默认：ParallelGC, 9、JVM 怎么调优, Redis, 1、Redis 数据类型, 2、Redis 分布式锁用在哪里哨兵机制, Redis 哨兵机制, 3、Redis 的 LUA 脚本有用过吗, 4、缓存雪崩、穿透、击穿、数据库一致, 1、缓存穿透：, 2、缓存雪崩：, 3、缓存击穿：, MQ, 1. 消息确认, 2. 消息堆积, 3. 消息丢失, 1. 消息在生产者丢失, 2. 消息在队列中丢失, 3. 消息在消费者丢失, 4. 重复消费, 5. 有序消费, 设计模式, 1、线程安全的单例模式基础的基本数据类型有哪些占几个字节八种基本类型六种数字类型四个整数型两个浮点型一种字符类型还有一种布尔型整型浮点型字符型布尔型序号数据类型位数字节默认值取值范围举例说明位短整数整数长整数单精度双精度字符布尔值类型比较结果分别是什么为什么为是因为直接这样创建类型的字符串时它是在字符串常量池中先查找是否有某个地址空间存在这个类型的对象如果没有就创建这样的对象然后将其所在的地址复制一份交给类型的变量空间中在申请创建类型的变量时会优先再次去字符串常量池去查看是否存在某个地址空间存在这个类型的对象因为之前已经创建过了所以直接将对象的地址直接复制一份交给为是因为这里采用关键字创建了类型的对象内属性数组中存储的是这个字符关键字一出说明这里是在堆内存中申请创建的对象空间所以地址空间肯定不一样是什么有用过哪里是面向切面编程可以在原有方法的基础上增加增强方法比较常用的日志记录在接口或者方法上面用注解的形式增加日志记录功能记录调用方法的时间操作内容操作人信息等信息还有动态切换数据源有些数据有地区之分需要动态的去切换地区使用对应的数据源原理线程安全吗原理主要用来存放键值对它基于哈希表的接口实现是常用的集合之一是非线程安全的可以存储的和但作为键只能有一个作为值可以有多个之前由数组链表组成的数组是的主体链表则是主要为了解决哈希冲突而存在的拉链法解决冲突以后的在解决哈希冲突时有了较大的变化如果当前数组的长度小于那么会选择先进行数组扩容而不是转换为红黑树当链表长度大于等于阈值默认为时将链表转化为红黑树以减少搜索时间默认的初始化大小为之后每次扩充容量变为原来的倍并且总是使用的幂作为哈希表的大小哈希冲突哈希表是有限的而键的数量可能是无限的因此不同的键经过哈希函数计算后可能会映射到相同的哈希桶数组的位置如果数组小于长度小于则会扩容初始大小为扩容为的幂次方在链表长度大于且数组长度大于时将链表转换为红黑树扩容机制当哈希表的负载因子超过阈值时即元素数量超过容量的乘积与负载因子的乘积将触发扩容操作默认情况下负载因子的阈值为扩容时会创建一个新的数组其容量为原数组的两倍遍历原数组中的每个非空桶将其中的键值对重新计算哈希值并根据新的数组长度定位到新的位置然后存储到新的数组中扩容操作完成后新数组中的桶链如果存在冲突的顺序可能发生改变但是哈希表的结构保持不变的方法首先判断数组是否为空如果是则进行初始化其次根据求出要添加对象所在的索引位置判断此索引的内容是否为空如果是则直接存储如果不是则判断索引位置的对象和要存储的对象是否相同首先判断值知否相等在判断是否相等两个对象的值不同一定不是同一个对象值相同两个对象也不一定相等如果是同一个对象则直接进行覆盖返回原值如果不是则判断是否为树节点对象如果是直接添加当既不是相同对象又不是树节点直接将其插入到链表的尾部在进行判断是否需要进行树化最后判断的是否达到阈值进行扩容处理底层原理使用锁加机制数组链表红黑树是一个类似于一个的结构它的冲突在达到一定大小时会转化成红黑树在冲突小于一定数量时又会退回链表方法如果没有初始化就先调用方法来进行初始化过程如果没有哈希冲突就直接插入如果还在进行扩容操作就先进行扩容如果存在哈希冲突就加锁来保证线程安全这里有两种情况一种是链表形式就直接遍历到尾端插入一种是红黑树就按照红黑树结构插入最后一个如果该链表的数量大于阈值就要先转换成黑红树的结构再一次进入循环如果添加成功就调用方法统计并且检查是否需要扩容和安全性是线程不安全的是线程安全的通过和实现的线程安全数据结构数组链表红黑树和的区别对和的支持支持的键和值不支持会报空指针线程安全线程不安全因为有修饰所以线程安全效率因为线程安全性单线程下比效率高初始容量初始大小为扩容为的幂次方初始为扩容为底层结构会将链表长度大于阈值是转化为红黑树会先判断当前数组的长度是否小于是则扩容而不转化将链表转化为红黑树以减少搜索时间没有这样的机制和的线程安全是因为使用单锁这极大的影响了性能放弃了单锁用的锁分离运行个线程阻塞在一个地方直到线程的任务都执行完使用线程池处理读取任务每一个线程处理完之后就将调用对象的方法直到所有文件读取完之后才会接着执行后面的逻辑和区别数据结构不同是动态数组的数据结构是链表的数据结构效率不同当随机访问和操作时比的效率更高因为可以根据下标进行查找是线性的数据存储方式所以需要移动指针从前往后依次查找当对数据进行增加和删除的操作和操作时比的效率更高因为在进行增删操作时会对操作数据的下标索引造成影响需要对操作数据附近的数据进行移动容量性质不同有一个初始容量刚创建对象时不会定义底层数组长度第一次调用方法时会初始化长度为之后调用方法会先调用方法判断够不够不够就会调用方法扩容长度变为原来的倍能够动态的随数据量的变化而变化主要控件开销不同主要控件开销在于需要在列表预留一定空间主要控件开销在于需要存储结点信息以及结点指针信息有没有可能会失效不加会怎么样失效的种情况应用在非修饰的方法上因为是基于动态代理实现的注解属性设置错误这种失效是由于配置错误若是错误的配置以下三种事务将不会发生回滚如果当前存在事务则加入该事务如果当前没有事务则以非事务的方式继续运行以非事务方式运行如果当前存在事务则把当前事务挂起以非事务方式运行如果当前存在事务则抛出异常注解属性设置错误可以指定能够触发事务回滚的异常类型默认抛出了未检查异常继承自的异常或者才回滚事务其他异常不会触发回滚事务如果在事务中抛出其他类型的异常但却期望能够回滚事务就需要指定属性同一个类中方法调用导致失效开发中避免不了会对同一个类里面的方法调用比如有一个类它的一个方法再调用本类的方法不论方法是用还是修饰但方法没有声明注解事务而方法有则外部调用方法之后方法的事务是不会起作用的这也是经常犯错误的一个地方流程用户通过浏览器发起请求到前端控制器前端控制器将请求发送到处理器映射器处理器映射器根据请求找到对应的处理器封装返回前端控制器前端控制器会根据返回的处理器找到对应的处理器适配器处理器适配器会调用对应的将处理结果和跳转视图封装到返回到处理器适配器处理器适配器将返回到前端控制器前端控制器调用视图解析器对解析视图解析器将解析出来的视图封装成视图对象返回前端控制器前端控制器调用视图对象进行视图渲染将数据模型填充到视图中形成前端控制器返回到浏览器展示在页面上同步并阻塞同步非阻塞异步非阻塞高并发线程的生命周期和状态线程的生命周期包含个阶段新建就绪运行阻塞销毁新建刚使用方法创建出来的线程就绪调用线程的方法后线程处于等待分配资源阶段当线程获取到资源后开始执行运行当就绪的线程被调度并获得资源时便会进入运行状态方法定义了线程的操作和功能阻塞在运行状态的时候可能因为某些原因导致运行状态的线程变成了阻塞状态如之后线程就会处于阻塞状态这个时候需要其他机制将处于阻塞状态的线程唤醒如方法被唤醒的线程不会立即执行方法会回到就绪阶段再次等待分配资源进入运行状态销毁如果线程正常执行完毕或被提前强制终止或出现异常导致结束那么线程就会被销毁并释放资源线程的个状态初始状态线程被创建出来但没有被调用运行状态线程被调用了等待运行的状态阻塞状态需要等待锁释放等待状态表示该线程需要等待其他线程做出一些特定动作通知或中断超时等待状态可以在指定的时间后自行返回而不是像那样一直等待终止状态表示该线程已经运行完毕阻塞的三种情况等待阻塞同步阻塞其他阻塞等待阻塞正在运行中的线程执行方法时会把该线程放入等待队列中同步阻塞运行的线程在获取对象的同步锁时若该同步锁被其他线程占用则会把该线程放入锁池中其他阻塞运行的线程执行方法或者发出了请求时会把该线程置为阻塞状态和的区别和的区别在于这两个方法来自不同的类分别是和方法没有释放锁而方法释放了锁使得其他线程可以使用同步控制块或者方法是线程被调用时占着去睡觉其他线程不能占用认为该线程正在工作不会让出系统资源是进入等待池等待让出系统资源其他线程可以占用一般不会加时间限制线程死亡的三种情况正常结束或方法执行完成线程正常结束异常结束线程执行过程中抛出一个未捕获的异常导致结束强制结束调用线程终止方法强制结束线程使用退出标志定义一个修饰的型的标志位在线程的方法中根据这个标志位是为还是为来判断是否终止这种情况多用于循环中使用目的是保证可见性一处修改了标志处处都要去主存读取新的值而不是使用缓存方法使用方法中断线程有两种情况线程处于阻塞状态如使用了同步锁的中的等方法时会使线程处于阻塞状态当调用线程的方法时会抛出异常阻塞中的那个方法抛出这个异常通过代码捕获该异常然后跳出循环状态从而让我们有机会结束这个线程的执行阻塞线程中断线程抛出异常强制跳出线程中断线程未处于阻塞状态使用判断线程的中断标志来退出循环当使用方法时中断标志就会置和使用自定义的标志来控制循环是一样的道理中断线程通过循环不断确认线程是否已经终止线程中断方法调用方法该方法不安全容易导致死锁调用方法会立刻终止方法中剩余的全部任务包括或中的任务并且抛出异常因此可能会导致任务执行失败调用方法会立刻释放改线程所持有的所有锁导致数据无法完成同步出现数据不一致的问题创建线程的三种方式线程池的好处创建线程的三种方式个继承两个实现继承类实现接口不用担心单继承没有返回值实现接口方法获取返回值有返回值也可以抛出异常区别只能单继承和可以多实现和不能得到返回值可以获取返回值及捕获异常使用线程池的好处降低资源消耗通过重复利用已创建的线程降低线程创建和销毁造成的消耗提高响应速度当任务到达时任务可以不需要等到线程创建就能立即执行提高线程的可管理性线程是稀缺资源如果无限制的创建不仅会消耗系统资源还会降低系统的稳定性使用线程池可以进行统一的分配调优和监控如何创建线程池通过构造方法实现核心线程最大线程空闲线程存活时间单位秒阻塞队列类型容量线程工程默认饱和策略抛出来拒绝新任务的处理个参数核心线程数核心线程数定义了最小可以同时运行的线程数量最大线程数当队列中存放的任务达到队列容量的时候当前可以同时运行的线程数量变为最大线程数阻塞队列当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数如果达到的话新任务就会被存放在队列中存活时间当线程池中的线程数量大于的时候如果这时没有新的任务提交核心线程外的线程不会立即销毁而是会等待直到等待的时间超过了才会被回收销毁存活时间单位参数的时间单位线程工厂创建新线程的时候会用到饱和策略如果当前同时运行的线程数量达到最大线程数量并且阻塞队列也已经被放满了任务时会根据饱和策略来处理多余的任务常见饱和策略抛出异常来拒绝新任务的处理调用执行自己的线程运行任务也就是直接在调用方法的线程中运行被拒绝的任务如果执行程序已关闭则会丢弃该任务因此这种策略会降低对于新任务提交速度影响程序的整体性能如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话你可以选择这个策略不处理新任务直接丢弃掉此策略将丢弃最早的未处理的任务请求线程池运行流程线程池创建准备好数量的核心线程准备接受任务新的任务进来用准备好的空闲线程执行核心线程满了就将再进来的任务放入阻塞队列中空闲的就会自己去阻塞队列获取任务执行阻塞队列满了就直接开新线程执行最大只能开到指定的数量如果线程数开到了的数量还有新任务进来就会使用指定的拒绝策略拒绝任务都执行完成有很多空闲在指定后会释放数量空闲的线程最终保持到大小默认是的最大值内存不够所有的线程创建都是由指定的创建的总结核心线程阻塞队列新线程拒绝策略自动释放空闲核心线程通过框架的工具类来实现种常见线程池创建一个可缓存线程池如果线程池长度超过处理需要可灵活回收空闲线程若无可回收则新建线程没有核心线程所有线程都可以回收创建一个定长线程池可控制线程最大并发数超出的线程会在队列中等待核心线程数和最大线程数相同固定线程数大小所有线程都不可以回收创建一个定长线程池支持定时及周期性任务执行可以指定多长时间以后执行任务定时任务线程池创建一个单线程化的线程池它只会用唯一的工作线程来执行任务保证所有任务按照指定顺序优先级执行单线程的线程池核心和最大线程数都为后台从队列中取一个执行一个相当于后台用单线程执行任务和的区别方法用于提交不需要返回值的任务所以无法判断任务是否被线程池执行成功与否方法用于提交需要返回值的任务线程池会返回一个类型的对象通过这个对象可以判断任务是否执行成功并且可以通过的方法来获取返回值方法会阻塞当前线程直到任务完成而使用方法则会阻塞当前线程一段时间后立即返回这时候有可能任务没有执行完并发包下常用的类库的选择各种优缺点实现了实现了是根据配置实现和核心思想如果被请求的共享资源空闲则将当前请求资源的线程设置为有效的工作线程并且将共享资源设置为锁定状态如果被请求的共享资源被占用那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制这个机制是基于锁实现的是指是一种经典的自旋锁算法用于解决并发环境下的互斥访问问题自旋锁是一种基于链表的软件锁算法采用了无忙等待的自旋方式避免了传统自旋锁的缺点自旋锁的核心思想是使用一个链表来表示所有等待获取锁的线程链表中的每个节点代表一个竞争线程每个节点都维护一个标志位用来表示前一个节点是否已经释放了锁自旋锁的获取和释放过程如下获取锁当线程需要获取锁时它会创建一个新的节点并将自己加入到链表的末尾然后它会自旋等待不断检查前一个节点的标志位直到前一个节点释放了锁释放锁当线程释放锁时它会将自己所对应的节点的标志位置为已释放并将其从链表中移除这样后续等待的线程就可以通过自旋获取锁自旋锁的特点包括无忙等待自旋锁通过自旋等待的方式来获取锁避免了传统自旋锁在竞争激烈情况下的忙等待问题减少了对的占用提高了性能队列自旋锁的链表是按照线程请求锁的顺序排队的保证了公平性避免了饥饿现象的发生缓存友好性自旋锁的节点通过自旋等待获取锁而不是忙等待这样可以减少对共享变量的频繁访问提高了缓存的命中率需要注意的是自旋锁在多处理器系统上的性能通常比较好但在单处理器系统上可能存在性能问题因为它会导致线程频繁地进行上下文切换在实际使用时需要根据具体的环境和需求来选择合适的锁算法锁是对自旋锁的一种改进是一个虚拟的双向队列虚拟的双向队列即不存在队列实例仅存在结点之间的关联关系暂时获取不到锁的线程将被加入到该队列中将每条请求共享资源的线程封装成一个队列锁的一个结点来实现锁的分配在队列锁中一个节点表示一个线程它保存着线程的引用当前节点在队列中的状态前驱节点后继节点什么是钩子方法钩子方法是一种被声明在抽象类中的方法一般使用关键字修饰它可以是空方法由子类实现也可以是默认实现的方法模板设计模式通过钩子方法控制固定步骤的实现的全称是比较与交换用于实现乐观锁被广泛应用于各大框架中的思想很简单就是用一个预期值和要更新的变量值进行比较两值相等才会进行更新操作是原子性的即在执行期间不会被其他线程中断从而确保了线程安全它实际上是利用了现代处理器提供的原子指令比如的指令来实现的操作由三个参数组成要更新的变量值预期值拟写入的新值它的执行过程如下检查变量值是否等于预期值如果相等则将该地址上的值更新为新值如果不相等则表示其他线程已经修改了该值操作失败举一个简单的例子线程要修改变量的值为原值为假设不存在问题与进行比较如果相等则说明没被其他线程修改可以被设置为与进行比较如果不相等则说明被其他线程修改当前线程放弃更新操作失败的优点在于它避免了使用锁带来的线程切换和上下文切换的开销从而减少了系统开销和提高了并发性能然而也存在一些限制和问题主要包括问题如果变量的值在操作过程中被其他线程从预期值变为又变回预期值操作可能会误判无法感知到变量的变化问题的解决思路是在变量前面追加上版本号或者时间戳以后的类就是用来解决问题的其中的方法就是首先检查当前引用是否等于预期引用并且当前标志是否等于预期标志如果全部相等则以原子方式将该引用和该标志的值设置为给定的更新值为了解决的限制提供了包下的一系列原子类如等它们封装了操作提供了更便捷和安全的方式来进行原子操作阻塞队列是中的一个线程安全线程同步的固定大小的阻塞队列它是基于数组实现的它是在包下的一个类的主要特点有有界性的容量是固定的即在创建队列时必须指定队列的容量大小先进先出严格按照元素的插入顺序进行操作保证先进来的元素先被获取线程安全使用内部锁实现了线程安全它对插入和删除操作进行了同步以确保多线程环境下的并发操作不会出现问题阻塞操作支持阻塞操作当队列为空时从队列中获取元素的操作会被阻塞直到有元素可用当队列已满时插入元素的操作会被阻塞直到队列有空闲位置可用支持可选的公平性可以通过构造函数设置公平性参数如果设置为则等待时间更长的线程会优先获得锁使用可以方便地实现生产者消费者模式生产者线程将元素插入队列消费者线程从队列中获取元素当队列为空时消费者线程会被阻塞直到队列中有元素可用当队列已满时生产者线程会被阻塞直到队列有空闲位置可用需要注意的是在中当队列已满时尝试插入元素会导致线程被阻塞当队列为空时尝试获取元素也会导致线程被阻塞因此在使用时要合理处理阻塞操作可能引发的线程安全和性能问题锁在并发编程中锁是用于控制对共享资源的访问的一种同步机制它用于确保在同一时间内只有一个线程可以访问被锁定的资源从而保证线程安全显示锁显式锁是由代码明确调用的锁机制在中是一个常见的显式锁实现它提供了显式的和方法来控制对临界区的访问隐式锁隐式锁是由语言或运行时环境自动管理的锁机制在中关键字就是一种隐式锁机制它可以应用于方法或代码块隐式地在进入和退出临界区时获取和释放锁互斥锁互斥锁是一种特殊类型的锁用于保护共享资源的互斥访问当一个线程获取了互斥锁后其他线程必须等待锁的释放才能访问共享资源互斥锁提供了排他性保证同一时间只有一个线程能够持有锁自旋锁自旋锁是一种特殊类型的锁采用忙等待的方式来实现线程的同步当一个线程尝试获取自旋锁时如果锁已经被其他线程占用该线程会进入忙等待状态不断循环检查锁是否被释放自旋锁一般适用于锁的持有时间较短的情况避免线程切换带来的开销总而言之锁是一种用于实现并发编程中线程同步和对共享资源进行保护的机制它可以防止多个线程同时修改共享资源从而确保数据的一致性和线程的安全性不同类型的锁有不同的特点和适用场景开发者需要根据具体需求选择合适的锁机制是中的关键字用于修饰变量它具有以下两个主要的作用可见性使用修饰的变量对所有线程可见当一个线程修改了变量的值该变量的新值会立即被写入主内存并且其他线程可以立即看到最新的值这解决了多线程间的可见性问题避免了使用普通变量时的数据不一致性问题禁止指令重排序使用修饰的变量的读写操作会被插入到内存屏障之前和之后防止指令重排序优化这保证了变量的读写操作具有所谓的关系即写操作发生在后续的读操作之前确保了操作的有序性需要注意的是提供的可见性和禁止指令重排序的保证是有限的它并不能保证原子性对于复合操作如的原子性操作无法保证线程安全需要使用其他同步机制如锁或者使用原子类如来实现使用的常见场景包括标志位用于控制并发任务的启动暂停或停止双重检查锁定用于在延迟初始化对象的情况下确保多个线程能够正确地获取初始化后的对象总结来说是一种用于保证变量可见性和禁止指令重排序的关键字它提供了一种简单而轻量的线程同步机制适用于某些特定的并发场景然而对于更复杂的线程同步需求需要使用更强大的同步机制如锁来确保线程安全性是中的关键字用于实现线程之间的同步和互斥访问它可以应用于方法或代码块用于控制对共享资源的访问并保证多个线程对共享资源的安全性使用的主要作用包括互斥访问当多个线程同时访问同一个被修饰的方法或代码块时只会有一个线程能够进入临界区其他线程需要等待这样可以确保在同一时间内只有一个线程对共享资源进行操作避免了数据的竞争和不一致性可见性和有序性除了提供互斥访问之外还提供了对变量的可见性和有序性保证当一个线程释放的锁时它会将对共享变量的更新刷新到主内存中使得其他线程能够立即看到最新的值并且保证了操作的有序性使用的方式有两种同步方法使用修饰的方法称为同步方法当线程调用同步方法时它会自动获取该方法所属对象或类的锁并在方法执行过程中保持独占其他线程需要等待锁的释放才能执行相同对象或类的同步方法同步代码块使用修饰的代码块称为同步代码块它需要指定一个对象作为锁也称为监视器对象同一时间只有一个线程可以持有该对象的锁并执行进入锁定的代码块其他线程需要等待该锁的释放才能执行相同对象的同步代码块需要注意的是是一种重量级的锁机制涉及到线程的上下文切换和内核态的操作在使用时应尽量减小同步范围避免持有锁的时间过长以提高程序的性能总结来说是一种用于实现线程同步和互斥访问的关键字它能够保证对共享资源的原子性操作可见性和有序性并防止多个线程同时修改共享资源在多线程编程中使用是一种常见且有效的同步机制微服务微服务事务解决方案等是一种常见的分布式事务协议用于实现多个参与者之间的一致性它通过协调器和参与者之间的协作来确保在分布式环境中的事务的一致性协议的执行过程分为两个阶段准备阶段在该阶段协调器向所有参与者发出准备请求参与者执行事务操作并将准备状态通知协调器如果参与者成功执行并准备好提交事务则返回准备就绪状态如果有任何一个参与者无法准备好提交事务它将返回无法准备状态提交阶段如果所有参与者都返回了准备就绪状态协调器将发送提交请求给所有参与者参与者接收到提交请求后执行事务的最终提交操作并将提交确认通知协调器一旦协调器接收到所有参与者的提交确认它将发出全局提交的通知通过这个两阶段的协作协议实现了分布式事务的提交一致性但是协议也存在一些缺点阻塞问题在的执行过程中参与者在等待协调器的请求时会阻塞这可能导致整个事务的执行时间较长并且会增加协调器故障的风险单点故障协调器作为中心化的组件一旦发生故障将导致整个协议无法继续执行从而影响整个分布式事务的一致性数据不一致问题协议在网络分区参与者故障或通信故障等情况下可能导致数据不一致的问题例如在准备阶段失败时已准备好的参与者可能无法回滚之前的操作导致数据不一致鉴于的缺点一些替代的分布式事务协议也被提出如等它们针对的一些问题进行了改进和优化此外一些基于补偿的事务处理模式如模式也被广泛应用于大规模微服务架构中在微服务架构中处理分布式事务是一个挑战性的任务其中是一种用于解决微服务事务一致性的解决方案之一是一种变种的协议专门用于处理微服务架构中的分布式事务它在传统的协议基础上进行了改进以提高性能和可靠性的主要思想是将事务划分为一组子事务每个子事务对应于一个微服务协调者负责协调所有子事务的一致性的执行过程如下准备阶段协调者将准备请求发送给所有子事务每个子事务执行自身的事务操作并将准备状态返回给协调者如果所有子事务都准备好提交事务则进入下一阶段否则如果有任何一个子事务无法准备好则中止整个事务提交阶段协调者将提交请求发送给所有准备好的子事务每个子事务执行自身的事务提交操作并将确认状态返回给协调者协调者等待所有子事务的确认如果所有子事务都成功确认则整个事务提交成功如果有任何一个子事务无法确认则中止整个事务通过协议微服务架构中的分布式事务可以实现一致性相较于传统的协议减少了等待时间并且在部分子事务失败的情况下能够快速中止整个事务减少了不必要的等待和资源占用需要注意的是尽管在解决微服务事务一致性方面具有一定的优势但它仍然可能遭遇网络分区故障恢复等问题因此针对具体的应用场景可能还需要结合其他技术和策略来提高事务处理的可靠性和性能理论在项目中的取舍定理一致性可用性分区容错性这三个指标不可能同时做到这个结论就叫做定理分区容错性比如一台服务器放在中国另一台服务器放在美国这就是两个区它们之间可能无法通信介于分区状态下和是两台跨区的服务器向发送一条消息可能无法收到因为网络总是不可靠的因此可以认为总是成立的可用性只要收到用户的请求服务器就必须给出回应但此时由于网络问题会导致服务器之间的数据无法做到实时同步牺牲了一致性此时满足一致性用户访问系统用户访问系统系统和系统保持同步当用户对系统的做出更改后用户查询系统的时需要查询出用户操作后的数据而同步是要通过网络网络却又总是不可靠的所以为确保用户能查询出用户修改的数据必须在用户查询前将系统的同步到系统上这样就牺牲了可用性此时满足理论由于中一致性和可用性无法兼得的架构师提出了理论它是通过牺牲数据的强一致性来获得可用性它有如下种特征基本可用分布式系统在出现不可预知故障的时候允许损失部分可用性保证核心功能的可用软状态软状态也称为弱状态和硬状态相对是指允许系统中的数据存在中间状态并认为该中间状态的存在不会影响系统的整体可用性即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时最终一致性最终一致性强调的是系统中所有的数据副本在经过一段时间的同步后最终能够达到一个一致的状态因此最终一致性的本质是需要系统保证最终数据能够达到一致而不需要实时保证系统数据的强一致性理论并没有要求数据的强一致性而是允许数据在一定的时间段内是不一致的但在最终某个状态会达到一致在生产环境中很多公司会采用理论来实现数据的一致因为产品的可用性相比强一致性来说更加重要比如在电商平台中当用户对一个订单发起支付时往往会调用第三方支付平台比如支付宝支付或者微信支付调用第三方成功后第三方并不能及时通知我方系统在第三方没有通知我方系统的这段时间内我们给用户的订单状态显示支付中等到第三方回调之后我们再将状态改成已支付虽然订单状态在短期内存在不一致但是用户却获得了更好的产品体验数据库存储引擎有哪些默认的存储引擎是什么为什么用这个存储引擎事务安全支持外键支持全文索引适用场景需要事务支持行级锁定对高并发有很好地适应能力但需要确保查询是通过索引完成数据更新较为频繁存储引擎不是事务安全的不支持外键表格可以被压缩且支持全文索引不支持缓存数据文件适用场景不需要事务支持并发相对较低数据修改相对较少以读为主数据一致性要求不是特别高存储引擎把表临时性存放在内存中数据库重启或崩溃数据就会丢失默认使用哈希索引只支持表锁并发性能较差不支持和列类型浪费内存比如存储变长字段时是按照定长字段的方式进行的存储引擎是一组表的组合对表进行操作这个操作只删除的定义对内部的表没有任何影响对表的大小有要求不能是太大的表适用场景需要很快的读写速度对数据安全性要求较低默认的存储引擎版本之前默认引擎是之后是和的区别支持事务而不支持事务支持外键而不支持外键是行锁而是表锁每次更新增加删除都会锁住表和的索引都是基于树但他们具体实现不一样的树的叶子节点是存放数据的的树的叶子节点是存放指针的是聚簇索引必须要有主键一定会基于主键查询但是辅助索引就会查询两次是非聚簇索引索引和数据是分离的索引里保存的是数据地址的指针主键索引和辅助索引是分开的不存储表的行数所以的时候会全表查询而会存放表的行数的时候会查的很快数据库事务特性事务的隔离级别事务就是对数据的一系列操作事务的个特性原子性事务是最小的执行单位不允许分割事务的原子性确保动作要么全部完成要么完全不起作用一致性执行事务前后数据保持一致例如转账业务中无论事务是否成功转账者和收款人的总额应该是不变的隔离性并发访问数据库时一个用户的事务不被其他事务所干扰各并发事务之间数据库是独立的持久性一个事务被提交之后它对数据库中数据的改变是持久的即使数据库发生故障也不应该对其有任何影响只有保证了事务的持久性原子性隔离性之后一致性才能得到保障并发事务会产生哪些问题脏读当一个事务正在访问数据并且对数据进行了修改而这种修改还没有提交到数据库中这时另外一个事务也访问了这个数据然后使用了这个数据因为这个数据是还没有提交的数据那么另外一个事务读到的这个数据是脏数据依据脏数据所做的操作可能是不正确的丢失修改指在一个事务读取一个数据时另外一个事务也访问了该数据那么在第一个事务中修改了这个数据后第二个事务也修改了这个数据这样第一个事务内的修改结果就被丢失因此称为丢失修改例如事务读取某表中的数据事务也读取事务修改事务也修改最终结果事务的修改被丢失不可重复读指在一个事务内多次读同一数据在这个事务还没有结束时另一个事务也访问该数据那么在第一个事务中的两次读数据之间由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样这就发生了在一个事务内两次读到的数据是不一样的情况因此称为不可重复读幻读幻读与不可重复读类似它发生在一个事务读取了几行数据接着另一个并发事务插入了一些数据时在随后的查询中第一个事务就会发现多了一些原本不存在的记录就好像发生了幻觉一样所以称为幻读不可重复读和幻读有什么区别不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改幻读的重点在于记录新增比如多次执行同一条查询语句时发现查到的记录增加了事务的个隔离级别读未提交最低的隔离级别允许读取尚未提交的数据变更可能会导致脏读幻读或不可重复读读已提交允许读取并发事务已经提交的数据可以阻止脏读但是幻读或不可重复读仍有可能发生可重复读对同一字段的多次读取结果都是一致的除非数据是被本身事务自己所修改可以阻止脏读和不可重复读但幻读仍有可能发生可串行化最高的隔离级别所有的事务依次逐个执行这样事务之间就完全不可能产生干扰也就是说该级别可以防止脏读不可重复读以及幻读隔离级别脏读不可重复读幻读索引的优缺点组合索引特性优点使用索引可以大大加快数据的检索速度大大减少检索的数据量这也是创建索引的最主要的原因通过创建唯一性索引可以保证数据库表中每一行数据的唯一性缺点创建索引和维护索引需要耗费许多时间当对表中的数据进行增删改的时候如果数据有索引那么索引也需要动态的修改会降低执行效率索引需要使用物理文件存储也会耗费一定空间外联接和内联接的区别内连接指连接结果仅包含符合连接条件的行参与连接的两个表都应该符合连接条件外连接连接结果不仅包含符合连接条件的行同时也包含自身不符合条件的行包括左外连接右外连接和全外连接左外连接左边表数据行全部保留右边表保留符合连接条件的行右外连接右边表数据行全部保留左边表保留符合连接条件的行全外连接左外连接右外连接索引失效场景及原理索引失效场景及原理使用函数或表达式在子句中对索引列使用函数或表达式会导致索引失效因为无法预先计算表达式的结果所以无法使用索引进行查找例原理此查询中函数作用在索引列上导致索引失效隐式类型转换如果查询条件与索引列类型不匹配会进行隐式类型转换可能导致索引失效例原理此查询中假设字段是整数类型而查询条件使用了字符串类型导致类型不匹配会尝试将字段转换为字符串从而导致索引失效不等于或操作符使用不等于操作符会导致索引失效因为无法利用索引进行范围查找例原理此查询中由于使用了不等于操作符无法利用索引进行查找因此索引失效范围查询的多列索引对于多列联合索引如果查询条件中包含范围查询如等那么在范围查询之后的索引列将失效例原理假设存在一个多列联合索引此查询中对进行了范围查询使得索引列之后的索引失效连接的条件使用连接的条件可能导致索引失效尤其是在条件中涉及多个索引列时例原理此查询中由于使用了连接可能无法同时利用和两个索引列进行查找导致索引失效查询如果在查询中通配符或在字符串的开头将导致索引失效例原理此查询中由于通配符在字符串的开头无法使用索引进行查找因此索引失效需要注意的是实际查询优化器会根据数据量数据分布等因素决定是否使用索引全文索引全文索引全文索引的创建和使用创建全文索引字段名字段名字段名和常用的不同全文索引有自己的格式使用和关键字如下关键字实际执行顺序书写顺序执行顺序的执行顺序确定查询的数据来源执行笛卡尔积生成基础数据集选择后面跟的表产生虚拟表对于操作应用条件从笛卡尔积生成的结果中筛选出匹配的行形成新的结果集是的连接条件符合连接条件的行会被记录在虚拟表中根据类型合并表如果有多个链接会重复执行步骤直到处理完所有表对上一步产生的结果集应用行级别的筛选条件进一步减少行数对虚拟表进行条件过滤符合条件的记录会被插入到虚拟表中根据子句中的列对虚拟表中的记录进行分组操作产生虚拟表对分组后的数据集应用条件过滤只保留满足条件的组对虚拟表进行过滤符合条件的记录会被插入到虚拟表中到一步才执行选择指定的列插入到虚拟表中从处理过的数据集中选择指定的列执行投影操作这可能包括对列进行计算使用别名等连接的两个查询语句会重复执行步骤产生两个虚拟表会将这些记录合并到虚拟表中将结果集按照指定的列排序将虚拟表中的记录进行排序虚拟表限制返回结果的数量或跳过指定数量的行后开始返回结果取出指定行的记录返回结果集的内存结构按线程来讲可以分成两部分一个是线程独占的一个是线程共享的线程共享的有方法区和堆堆包括年轻代与老年代字符串常量池年轻代由一个与两个区方法区方法区是虚拟机的模型规范具体实现是元空间和永久代永久代是的以后永久代就被移除了就变成元空间了元空间是分布在计算机内存中的是脱离了虚拟机内存的是独立存在的线程独占的是虚拟机栈本地方法栈程序计数器常用参数初始堆内存大小设定程序启动时占用内存大小默认物理内存最大堆内存设定程序运行期间最大可占用的内存大小如果程序运行需要占用更多的内存超出了这个设置值就会抛出异常默认物理内存上图中的与设置的大小一样设置年轻代大小整个堆大小年轻代大小年老代大小常量池持久代一般固定大小为所以增大年轻代后将会减小年老代大小此值对系统性能影响较大官方推荐配置为整个堆的设置单个线程栈大小一般默认单个线程栈大小跟操作系统和版本都有关系元空间大小元空间本质跟永久代类似都是对规范中方法区的实现不过元空间与永久代最大的区别在于元空间并不在虚拟机中而是使用本地内存由操作系统支配因此元空间大小仅受本地内存限制打印详细日志信息幸存者比例设置设置年轻代中区与区的大小比值设置为则两个区与一个区的比值为一个区占整个年轻代的新生代比例设置包括和两个区与年老代的比值除去持久代设置为则年轻代与年老代所占比值为年轻代占整个堆栈的进入老年代阈值设置常用工具查看进程及其相关的信息主要作用为实时查看和调整虚拟机各项参数查看堆内对象示例的统计信息的信息以及队列也可以生成程序的文件用来分析生成文件的命令查看运行时的状态信息包括内存状态垃圾回收等查看线程快照的命令线程快照是当前线程正在执行的方法堆栈集合使用命令可以定位线程出现长时间卡顿的原因例如死锁死循环等还可以查看程序崩溃时生成的文件中的信息类加载机制加载验证准备解析初始化加载根据类的完整路径查找二进制文件根据二进制文件创建类对象存储在堆中验证验证加载内容是否安全是否会对虚拟机造成异常验证文件格式元数据和字节码准备准备给类变量在方法区中进行内存分配初始化赋零值给初始值占坑解析把常量池的符号引用转变成直接引用在内存中通过这个引用找到目标初始化执行代码进行初始化执行静态代码块给静态变量赋值类加载器有哪些启动类加载器扩展类加载器系统类加载器自定义类加载器双亲委派是什么当一个类要使用类加载器进行类加载时会先请求委派给父类加载当父类还有父类时会继续往上委派一直到顶当父类加载器无法完成这个请求的时候子类才会尝试去加载为什么要有双亲委派认定两个对象同属于一个类型垃圾回收算法常用的有哪些标记清除标记复制标记整理分代常见的几种垃圾收集器默认的垃圾收集器是什么常见的几种种经典垃圾回收器串行回收器并行回收器并发回收器收集器串行收集器是最基本历史最悠久的垃圾收集器了单线程的收集器收集垃圾时必须使用复制算法收集器是收集器的老年代版本单线程收集器使用标记整理算法它主要有两大用途一种用途是在以及以前的版本中与收集器搭配使用另一种用途是作为收集器的后备方案启用命令收集器收集器其实就是收集器的多线程版本除了使用多线程进行垃圾收集外其余行为控制参数收集算法回收策略等等和收集器类似默认的收集线程数跟核数相同当然也可以用参数指定收集线程数但是一般不推荐修改收集器关注点是达到一个可控的吞叶量所谓吞吐量就是中用于运行用户代码的时间与总消耗时间的比值如果虚拟机总共运行分钟其中垃圾花掉分钟香叶量就是新生代采用复制算法老年代采用标记整理算法收集器收集器的老年代版本使用多线程和标记整理算法在注重吞吐量以及资源的场合都可以优先考虑收集器和收集器默认的新生代和老年代收集器启用命令年轻代老年代收集器收集器其实跟收集器很类似区别主要在于它可以和收集器配合使用新生代采用复制算法老年代采用标记整理算法收集器收集器是一种以获取最短回收停顿时间为目标的收集器它非常符合在注重用户体验的应用上使用它是虚拟机第一款真正意义上的并发收集器它第一次实现了让垃圾收集线程与用户线程基本上同时工作整个过程分为个步骤初始标记并发标记重新标记并发清理并发重置收集器标记整理算法实现运作流程主要包括以下初始标记并发标记最终标记筛选回收不会产生空间碎片可以精确地控制停顿默认新生代使用收集器使用的算法是基于标记复制算法实现收集器的目标是达到一个可控制的吞吐量如何计算吞吐量用户代码运行时间代码运行时间垃圾收集时间重点关注一个参数吧这个参数激活后不需要人工的指定新生代大小与区的比例晋升老年代对象大小等参数了虚拟机会根据当前系统运行情况收集性能监控信息动态调整这些参数以提供最合适的停顿时间合或最大的吞吐量老年带使用的是收集器是的老年代版本基于标记整理算法实现支持多线程并行收集他的出现缓解了的尴尬处境因为和别的优秀的老年代收集器不搭出现后他俩搭配才让吞吐量优先的收集器名副其实怎么调优调优总结数据类型分布式锁用在哪里哨兵机制当多个线程想要去操作同一个缓存数据时通过分布式锁将其锁住并设置一个到期时间防止业务异常导致无法解锁在查询一个数据的时候先用分布式锁将其锁住然后继续查询先从缓存里面查查不到再从数据库查并且把查询结果保存到缓存中然后返回结果然后删除分布式锁当下一个操作线程进入时同样锁住然后执行业务可以从缓存中取到值就是防止缓存穿透哨兵机制的四种模式单机主从哨兵集群的脚本有用过吗在分布式锁用过在代码中调用方法参数用执行官方文档上的脚本删除分布式锁缓存雪崩穿透击穿数据库一致三者出现的根本原因是缓存命中率下降请求直接打到上了正常情况下大量的资源请求都会被响应在得不到响应的小部分请求才会去请求这样的压力是非常小的是可以正常工作的如果大量的请求在上得不到响应那么就会导致这些请求会直接去访问导致的压力瞬间变大而卡死或者宕机大量的高并发的请求打在上这些请求发现上并没有需要请求的资源命中率降低因此这些大量的高并发请求转向数据库服务器请求对应的资源压力瞬间增大直接将打垮进而引发一系列灾害缓存穿透是指用户查询数据在数据库没有自然在缓存中也不会有这样就导致用户查询的时候在缓存中找不到每次都要去数据库再查询一遍然后返回空相当于进行了两次无用的查询这样请求就绕过缓存直接查数据库这也是经常提的缓存命中率问题解决根本原因结合上文就是请求根本不存在的资源对空值进行缓存类似于上面的例子虽然数据库中没有的用户的数据但是在中对他进行缓存这样当请求到达的时候就会直接返回一个的值给客户端避免了大量无法访问的数据直接打在上实时监控对进行实时监控当发现中的命中率下降的时候进行原因的排查配合运维人员对访问对象和访问数据进行分析查询从而进行黑名单的设置限制服务使用布隆过滤器使用作为布隆过滤器将目前所有可以访问到的资源通过简单的映射关系放入到布隆过滤器中哈希计算当一个请求来临的时候先进行布隆过滤器的判断如果有那么才进行放行否则就直接拦截接口校验类似于用户权限的拦截对于这些无效访问就直接拦截不允许这些请求到达上缓存雪崩我们可以简单的理解为由于原有缓存失效新缓存未到时间例如我们设置缓存时采用了相同的过期时间在同一时刻出现大面积的缓存过期所有原本应该访问缓存的请求都去查询数据库了而对数据库和内存造成巨大压力严重的会造成数据库宕机从而形成一系列连锁反应造成整个系统崩溃解决产生的原因中大量的集体过期将失效时间分散开通过使用自动生成随机数使得的过期时间是随机的防止集体过期使用多级架构使用缓存缓存其他缓存不同层使用不同的缓存可靠性更强设置缓存标记记录缓存数据是否过期如果过期会触发通知另外的线程在后台去更新实际的使用锁或者队列的方式如果查不到就加上排它锁其他请求只能进行等待缓存击穿某个非常非常热访问非常的频繁高并发访问的情况下当这个在失效可能过期了也可能淘汰了的瞬间大量的请求进来这时候就击穿了缓存直接请求到了数据库一下子来这么多数据库肯定受不了这就叫缓存击穿某个突然失效然后这时候高并发来访问这个结果缓存里没有都跑到了和缓存雪崩不同的是缓存击穿指并发查同一条数据缓存雪崩是不同数据都过期了很多数据都查不到从而查数据库解决产生的原因中的某个热点过期但是此时有大量的用户访问该过期提前对热点数据进行设置类似于新闻某博等软件都需要对热点数据进行预先设置在中监控数据适时调整监控哪些数据是热门数据实时的调整的过期时长使用锁机制只有一个请求可以获取到互斥锁然后到中将数据查询并返回到之后所有请求就可以从中得到响应消息确认消费者收到的每一条消息都必须进行确认自动确认和消费者自行确认消费者在声明队列时可以指定参数当时会等待消费者显式发回信号后才从内存和磁盘如果是持久化消息的话中移去消息否则会在队列中消息被消费后立即删除它采用消息确认机制后只要令消费者就有足够的时间处理消息任务不用担心处理消息过程中消费者进程挂掉后消息丢失的问题因为会一直持有消息直到消费者显式调用为止当时对于服务器端而言队列中的消息分成了两部分一部分是等待投递给消费者的消息一部分是已经投递给消费者但是还没有收到消费者信号的消息如果服务器端一直没有收到消费者的信号并且消费此消息的消费者已经断开连接则服务器端会安排该消息重新进入队列不会为未的消息设置超时时间它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的消费者连接是否已经断开这么设计的原因是允许消费者消费一条消息的时间可以很久很久消息堆积消息堆积的后果新消息无法进入队列旧消息无法丢失消息等待消费时间过长以至于超出了业务容许的范围消息堆积的原因生产者突然大量发布消息消费者来不及消费或消费失败消费者出现性能瓶颈消费者直接挂掉了如何解决消息堆积排查生产者是否突然大量发布消息限制下排查消费者消费性能瓶颈增加消费者的多线程处理缩短线程休眠时间等部署多个消费者排查消息队列可以想办法把消息按顺序的转移到另外一个新的队列让消费者消费新队列中的消息可以通过修改的两个参数来增大消费消息的并发数对每个在初始化的时候设置的并发消费者的个数每次一次性从里面取的待消费的消息的个数是内部维护的一个阻塞队列的大小其作用就是如果某个消费者队列阻塞就无法接收新的消息该消息会发送到其它未阻塞的消费者消息丢失消息分别在生产者消息队列消费者中丢失消息在生产者丢失原因生产者发送消息成功但没收到该消息一般由网络不稳定造成解决方案发送方采用消息确认机制当消息成功被接收到后会给生产者发送一个确认消息表示接收成功发送方确认模式有三种普通确认批量确认异步确认整合后只使用了异步监听确认模式消息在队列中丢失原因消息发送到后消息还没被消费却在中丢失了比如服务器宕机或者未进行持久化就进行了重启解决方案持久化交换机队列消息确保服务器异常重启时仍然能从磁盘恢复对应的交换机队列和消息然后我们把做多台分布式集群防止出现某一服务器挂掉消息在消费者丢失原因默认消费者消费消息时设置的是自动回复收到了消息会立刻删除自身保存的这条消息如果消息已经在中被删除但消费者的业务处理出现异常或消费者服务宕机那么就会导致该消息没有处理成功从而导致消息丢失解决方案消费者向的回复我们设置成手动回复配置成手动当消费者出现异常或者服务宕机时服务器不会删除该消息而是会把消息重发给绑定该队列的消费者如果该队列只绑定了一个消费者则该消息会一直保持在服务器直到消费者能正常消费为止正常业务逻辑应该是本地业务执行成功手动这条消息如果业务执行完毕手动的时候恰好服务宕机了重启这不是会造成重复消费吗没错这就牵扯的另一个问题了消息重复消费重复消费场景因消息重发机制会出现消息重复消费的情况解决方案幂等操作同一个操作执行次结果不变若实际业务中用不了幂等则保存消息到数据库中每次消费前查看消息是否已经被消费过有序消费场景在模式下只有一个队列但存在多个消费者多个消费者线程的竞争会导致数据乱序在简单队列模式下同样的多个消费者线程也会导致数据乱序解决方案使用多个队列对消息的值做再对队列数取模值队列数将结果相同的消息压入同一个队列中去这就保证了一个队列中有且仅有一个消费者在队列后的代码中消费方再为每一个线程加一个内存队列根据消息的求值然后把相同的结果压入同一个内存队列设计模式线程安全的单例模式',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-15 16:19:21',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">SherlockerSun</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Java/" style="font-size: 1.05rem;">Java<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Java/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Java</span></a></span></div></div><h1 class="post-title" itemprop="name headline">面试总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-07-15T08:17:40.000Z" title="发表于 2024-07-15 16:17:40">2024-07-15</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-07-15T08:19:21.105Z" title="更新于 2024-07-15 16:19:21">2024-07-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2024/07/15/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"><header><a href="/tags/Java/" tabindex="-1" itemprop="url">Java</a><h1 id="CrawlerTitle" itemprop="name headline">面试总结</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">SherlockerSun</span><time itemprop="dateCreated datePublished" datetime="2024-07-15T08:17:40.000Z" title="发表于 2024-07-15 16:17:40">2024-07-15</time><time itemprop="dateCreated datePublished" datetime="2024-07-15T08:19:21.105Z" title="更新于 2024-07-15 16:19:21">2024-07-15</time></header><h1 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h1><h2 id="1、Java的基本数据类型有哪些，占几个字节"><a href="#1、Java的基本数据类型有哪些，占几个字节" class="headerlink" title="1、Java的基本数据类型有哪些，占几个字节"></a>1、Java的基本数据类型有哪些，占几个字节</h2><p>八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p>
<ol>
<li><strong>整型：byte、short、int、long</strong></li>
<li><strong>浮点型：float、double</strong></li>
<li><strong>字符型：char</strong></li>
<li><strong>布尔型：boolean</strong></li>
</ol>
<table>
<thead>
<tr>
<th>序号</th>
<th>数据类型</th>
<th>位数</th>
<th>字节</th>
<th>默认值</th>
<th>取值范围</th>
<th>举例说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>byte(位)</td>
<td>8</td>
<td>1</td>
<td>0</td>
<td>-2^7 - 2^7-1</td>
<td>byte e &#x3D; 10;</td>
</tr>
<tr>
<td>2</td>
<td>short(短整数)</td>
<td>16</td>
<td>2</td>
<td>0</td>
<td>-2^15 - 2^15-1</td>
<td>short s &#x3D; 10;</td>
</tr>
<tr>
<td>3</td>
<td>int(整数)</td>
<td>32</td>
<td>4</td>
<td>0</td>
<td>-2^31 - 2^31-1</td>
<td>int i &#x3D; 10;</td>
</tr>
<tr>
<td>4</td>
<td>long(长整数)</td>
<td>64</td>
<td>8</td>
<td>0</td>
<td>-2^63 - 2^63-1</td>
<td>long l &#x3D; 10l;</td>
</tr>
<tr>
<td>5</td>
<td>float(单精度)</td>
<td>32</td>
<td>4</td>
<td>0.0</td>
<td>-2^31 - 2^31-1</td>
<td>float f &#x3D; 10.0f;</td>
</tr>
<tr>
<td>6</td>
<td>double(双精度)</td>
<td>64</td>
<td>8</td>
<td>0.0</td>
<td>-2^63 - 2^63-1</td>
<td>double d &#x3D; 10.0d;</td>
</tr>
<tr>
<td>7</td>
<td>char(字符)</td>
<td>16</td>
<td>2</td>
<td>null</td>
<td>0 - 2^16-1</td>
<td>char e &#x3D; ‘c’;</td>
</tr>
<tr>
<td>8</td>
<td>boolean(布尔值)</td>
<td>8</td>
<td>1</td>
<td>flase</td>
<td>true、false</td>
<td>boolean b &#x3D; true;</td>
</tr>
</tbody></table>
<h2 id="2、String类型比较"><a href="#2、String类型比较" class="headerlink" title="2、String类型比较"></a>2、String类型比较</h2><blockquote>
<p><strong>string a&#x3D;“string”</strong></p>
<p><strong>string b&#x3D;“string</strong></p>
<p><strong>string c&#x3D;new string（“string”）；</strong></p>
<p><strong>a &#x3D;&#x3D; b，a &#x3D;&#x3D; c，结果分别是什么，为什么</strong></p>
</blockquote>
<p>true，false</p>
<p>ab 为 true 是因为直接 String a&#x3D; “string”；这样创建 String 类型的字符串时，它是在字符串常量池中先查找是否有某个地址空间存在”string”这个 String 类型的对象，如果没有就创建”string”这样的对象，然后将其所在的地址复制一份交给 String 类型的变量空间 a 中，在申请创建 String 类型的变量 b 时，会优先再次去字符串常量池去查看是否存在某个地址空间存在”string”这个 String 类型的对象，因为之前已经创建过了，所以直接将对象”string”的地址直接复制一份交给 b。 </p>
<p>ac为false是因为 String c&#x3D; new String(“string”); 这里采用new关键字创建了String类型的对象内value属性数组中存储的是s,t,r,i,n,g这6个字符。new关键字一出，说明这里是在堆内存中申请创建的对象空间。所以地址空间肯定不一样.</p>
<h2 id="3、AOP是什么，有用过哪里"><a href="#3、AOP是什么，有用过哪里" class="headerlink" title="3、AOP是什么，有用过哪里"></a>3、AOP是什么，有用过哪里</h2><p>AOP 是面向切面编程，可以在原有方法的基础上增加增强方法，比较常用的日志记录，在接口或者方法上面用注解的形式增加日志记录功能，记录调用方法的时间、操作内容、操作人信息、ip 等信息。<br>还有动态切换数据源，有些数据有地区之分，需要动态的去切换地区，使用对应的数据源。</p>
<h2 id="4、HashMap-原理，线程安全吗"><a href="#4、HashMap-原理，线程安全吗" class="headerlink" title="4、HashMap 原理，线程安全吗"></a>4、HashMap 原理，线程安全吗</h2><h3 id="1-HashMap原理"><a href="#1-HashMap原理" class="headerlink" title="1.HashMap原理"></a>1.HashMap原理</h3><p>HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是非线程安全的。</p>
<p><code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个</p>
<p><strong>JDK1.8 之前</strong> HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。</p>
<p> <strong>JDK1.8 以后</strong>的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树，当链表长度大于等于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。</p>
<p><code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p>
<p><strong>哈希冲突：哈希表是有限的，而键的数量可能是无限的，因此不同的键经过哈希函数计算后可能会映射到相同的哈希桶（数组的位置）。</strong></p>
<p><strong>HashMap如果数组小于长度小于64则会扩容，HashMap初始大小为16，扩容为2的幂次方，在链表长度大于8，且数组长度大于64时将链表转换为红黑树。</strong></p>
<h3 id="2-HashMap扩容机制"><a href="#2-HashMap扩容机制" class="headerlink" title="2.HashMap扩容机制"></a>2.HashMap扩容机制</h3><ol>
<li>当哈希表的负载因子（load factor）超过阈值时，即元素数量超过容量的乘积与负载因子的乘积，HashMap 将触发扩容操作。默认情况下，负载因子的阈值为 0.75。</li>
<li>扩容时，HashMap 会创建一个新的数组，其容量为原数组的两倍。</li>
<li>遍历原数组中的每个非空桶，将其中的键值对重新计算哈希值，并根据新的数组长度定位到新的位置，然后存储到新的数组中。</li>
<li>扩容操作完成后，新数组中的桶链（如果存在冲突）的顺序可能发生改变，但是哈希表的结构保持不变。</li>
</ol>
<p><strong>HashMap的put方法：</strong></p>
<ol>
<li>首先判断数组是否为空，如果是，则进行初始化。</li>
<li>其次，根据**(n - 1) &amp; hash**求出要添加对象所在的索引位置，判断此索引的内容是否为空，如果是，则直接存储，</li>
<li>如果不是，则判断索引位置的对象和要存储的对象是否相同，首先判断hash值知否相等，在判断key是否相等。（1.两个对象的hash值不同，一定不是同一个对象。2.hash值相同，两个对象也不一定相等）。如果是同一个对象，则直接进行覆盖，返回原值。</li>
<li>如果不是，则判断是否为树节点对象，如果是，直接添加</li>
<li>当既不是相同对象，又不是树节点，直接将其插入到链表的尾部。在进行判断是否需要进行树化。</li>
<li>最后，判断hashmap的size是否达到阈值，进行扩容resize()处理。</li>
</ol>
<h3 id="3-ConcurrentHashMap底层原理"><a href="#3-ConcurrentHashMap底层原理" class="headerlink" title="3.ConcurrentHashMap底层原理"></a>3.ConcurrentHashMap底层原理</h3><blockquote>
<p>使用synchronized锁加CAS机制，Node数组+链表&#x2F;红黑树，node是一个类似于一个hashentry的结构。它的冲突在达到一定大小时会转化成红黑树，在冲突小于一定数量时又会退回链表。</p>
</blockquote>
<p>put方法</p>
<ol>
<li>如果没有初始化就先调用initTable（）方法来进行初始化过程</li>
<li>如果没有哈希冲突就直接CAS插入</li>
<li>如果还在进行扩容操作就先进行扩容</li>
<li>如果存在哈希冲突，就加锁来保证线程安全，这里有两种情况，一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入，</li>
<li>最后一个如果该链表的数量大于阈值8，就要先转换成黑红树的结构，break再一次进入循环</li>
<li>如果添加成功就调用addCount（）方法统计size，并且检查是否需要扩容</li>
</ol>
<h3 id="4-ConcurrentHashMap和HashMap"><a href="#4-ConcurrentHashMap和HashMap" class="headerlink" title="4.ConcurrentHashMap和HashMap"></a>4.ConcurrentHashMap和HashMap</h3><ol>
<li><p>安全性</p>
<p>HashMap是线程不安全的，ConcurrentHashMap是线程安全的，ConcurrentHashMap通过synchronized和CAS实现的线程安全。</p>
</li>
<li><p>数据结构</p>
<p>数组+链表&#x2F;红黑树</p>
</li>
</ol>
<h3 id="5-HashMap和HashTable的区别"><a href="#5-HashMap和HashTable的区别" class="headerlink" title="5.HashMap和HashTable的区别"></a>5.HashMap和HashTable的区别</h3><ol>
<li><p>对Null key 和Null value的支持</p>
<p>HashMap支持null的键(key)和值(value)，HashTable不支持null，会报空指针</p>
</li>
<li><p>线程安全</p>
<p>HashMap线程不安全，HashTable因为有synchronized修饰所以线程安全</p>
</li>
<li><p>效率</p>
<p>因为线程安全性，单线程下HashMap比HashTable效率高</p>
</li>
<li><p>初始容量</p>
<p>HashMap初始大小为16，扩容为2的幂次方。</p>
<p>HashTable初始为11，扩容为2n+1。</p>
</li>
<li><p>底层结构</p>
<p>HashMap会将链表长度大于阈值是转化为红黑树（会先判断当前数组的长度是否小于 64，是则扩容，而不转化），将链表转化为红黑树，以减少搜索时间。</p>
<p>Hashtable 没有这样的机制。</p>
</li>
</ol>
<h3 id="6-hashtable和concurrenthashmap"><a href="#6-hashtable和concurrenthashmap" class="headerlink" title="6.hashtable和concurrenthashmap"></a>6.hashtable和concurrenthashmap</h3><p>hashtable的线程安全是因为使用单锁，这极大的影响了性能</p>
<p>concurrenthashtable放弃了单锁，用的锁分离，synchronized+CAS</p>
<h3 id="7-CountDownLatch"><a href="#7-CountDownLatch" class="headerlink" title="7.CountDownLatch"></a>7.CountDownLatch</h3><p>运行count个线程阻塞在一个地方，直到线程的任务都执行完</p>
<p>使用线程池处理读取任务，每一个线程处理完之后就将 count-1，调用<code>CountDownLatch</code>对象的 <code>await()</code>方法，直到所有文件读取完之后，才会接着执行后面的逻辑</p>
<h2 id="5、ArrayList和LinkedList区别"><a href="#5、ArrayList和LinkedList区别" class="headerlink" title="5、ArrayList和LinkedList区别"></a>5、ArrayList和LinkedList区别</h2><ol>
<li><p>数据结构不同</p>
<p>ArrayList是Array(动态数组)的数据结构，LinkedList是Link(链表)的数据结构。</p>
</li>
<li><p>效率不同</p>
<p>当随机访问List（get和set操作）时，ArrayList比LinkedList的效率更高，因为ArrayList可以根据下标进行查找，LinkedList是线性的数据存储方式，所以需要移动指针从前往后依次查找。</p>
<p>当对数据进行增加和删除的操作(add和remove操作)时，LinkedList比ArrayList的效率更高，因为ArrayList在进行增删操作时，会对操作数据的下标索引造成影响，需要对操作数据附近的数据进行移动。</p>
</li>
<li><p>容量性质不同</p>
<p>ArrayList有一个初始容量，刚创建ArrayList对象时不会定义底层数组长度，第一次调用add方法时会初始化长度为10，之后调用add方法会先调用ensure方法判断够不够，不够就会调用grow方法扩容，长度变为原来的1.5倍。</p>
<p>LinkedList能够动态的随数据量的变化而变化。</p>
</li>
<li><p>主要控件开销不同</p>
<p>ArrayList主要控件开销在于需要在List列表预留一定空间；</p>
<p>LinkedList主要控件开销在于需要存储结点信息以及结点指针信息。</p>
</li>
</ol>
<h2 id="6、-Transactional（rollback-Exception-class），有没有可能会失效，不加-rollback-会怎么样"><a href="#6、-Transactional（rollback-Exception-class），有没有可能会失效，不加-rollback-会怎么样" class="headerlink" title="6、@Transactional（rollback&#x3D;Exception. class），有没有可能会失效，不加 rollback 会怎么样"></a>6、@Transactional（rollback&#x3D;Exception. class），有没有可能会失效，不加 rollback 会怎么样</h2><p>@Transactional 失效的 4 种情况：</p>
<ol>
<li><p><strong>@Transaction 应用在非 public 修饰的方法上</strong></p>
<p>因为 <code>@Transactional</code> 是基于动态代理实现的</p>
</li>
<li><p><strong>@Transactional 注解属性 propagation 设置错误</strong></p>
<p>这种失效是由于配置错误，若是错误的配置以下三种 propagation，事务将不会发生回滚。</p>
<ol>
<li><code>TransactionDefinition.PROPAGATION_SUPPORTS</code>：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code>：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><code>TransactionDefinition.PROPAGATION_NEVER</code>：以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ol>
</li>
<li><p><strong>@Transactional 注解属性 rollbackFor 设置错误</strong></p>
<p>rollbackFor 可以指定能够触发事务回滚的异常类型。Spring 默认抛出了未检查 unchecked 异常（继承自 RuntimeException 的异常）或者 Error 才回滚事务；其他异常不会触发回滚事务。如果在事务中抛出其他类型的异常，但却期望 Spring 能够回滚事务，就需要指定 rollbackFor 属性。</p>
</li>
<li><p><strong>同一个类中方法调用，导致 @Transactional 失效</strong></p>
<p>开发中避免不了会对同一个类里面的方法调用，比如有一个类 Test，它的一个方法 A，A 再调用本类的方法 B（不论方法 B 是用 public 还是 private 修饰），但方法 A 没有声明注解事务，而 B 方法有。则外部调用方法 A 之后，方法 B 的事务是不会起作用的。这也是经常犯错误的一个地方。</p>
</li>
</ol>
<h2 id="7、SpringMVC-流程"><a href="#7、SpringMVC-流程" class="headerlink" title="7、SpringMVC 流程"></a>7、SpringMVC 流程</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img-blog.csdnimg.cn/75ec98a325394e748c10d1903f4ee419.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6bqm55Sw6YeM55qE5a6I5pyb6ICF5ZGA,size_17,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<ol>
<li>用户通过浏览器发起 request 请求到前端控制器（DispatcherServlet）</li>
<li>前端控制器（DispatcherServlet）将请求发送到处理器映射器（HandlerMapping）</li>
<li>处理器映射器（HandlerMapping）根据请求找到对应的处理器（Controller），封装返回前端控制器（DispatcherServlet）</li>
<li>前端控制器（DispatcherServlet）会根据返回的处理器找到对应的处理器适配器（HandlerAdaptor）</li>
<li>处理器适配器（HandlerAdaptor）会调用对应的 Controller</li>
<li>Controller 将处理结果和跳转视图封装到 ModelAndView 返回到处理器适配器（HandlerAdaptor）</li>
<li>处理器适配器（HandlerAdaptor）将 ModelAndView 返回到前端控制器（DispatcherServlet）</li>
<li>前端控制器（DispatcherServlet）调用视图解析器（ViewResolver）对 ModelAndView 解析</li>
<li>视图解析器（ViewResolver）将解析出来的视图（View）封装成视图对象返回前端控制器（DispatcherServlet）</li>
<li>前端控制器（DispatcherServlet）调用视图对象进行视图渲染（将数据模型&lt; model &gt;填充到视图&lt; view &gt;中）, 形成 response</li>
<li>前端控制器（DispatcherServlet）返回 response 到浏览器，展示在页面上</li>
</ol>
<h2 id="8、BIO、NIO、AIO"><a href="#8、BIO、NIO、AIO" class="headerlink" title="8、BIO、NIO、AIO"></a>8、BIO、NIO、AIO</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40378034/article/details/119710529">https://blog.csdn.net/qq_40378034/article/details/119710529</a></p>
<ul>
<li>BIO：同步并阻塞</li>
<li>NIO：同步非阻塞</li>
<li>AIO：异步非阻塞</li>
</ul>
<h1 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h1><h2 id="1、线程的生命周期和状态"><a href="#1、线程的生命周期和状态" class="headerlink" title="1、线程的生命周期和状态"></a>1、线程的生命周期和状态</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/dca1f3f4588d">https://www.jianshu.com/p/dca1f3f4588d</a></p>
</blockquote>
<h3 id="1-线程的生命周期包含-5-个阶段：新建、就绪、运行、阻塞、销毁"><a href="#1-线程的生命周期包含-5-个阶段：新建、就绪、运行、阻塞、销毁" class="headerlink" title="1. 线程的生命周期包含 5 个阶段：新建、就绪、运行、阻塞、销毁"></a>1. 线程的生命周期包含 5 个阶段：<strong>新建</strong>、<strong>就绪</strong>、<strong>运行</strong>、<strong>阻塞</strong>、<strong>销毁</strong></h3><ol>
<li><p><strong>新建：</strong> 刚使用 new 方法创建出来的线程；</p>
</li>
<li><p><strong>就绪：</strong> 调用线程的 start ()方法后，线程处于等待 CPU 分配资源阶段，当线程获取到 CPU 资源后开始执行；</p>
</li>
<li><p><strong>运行：</strong> 当就绪的线程被调度并获得 CPU 资源时，便会进入运行状态，run ()方法定义了线程的操作和功能；</p>
</li>
<li><p><strong>阻塞：</strong> 在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，如 sleep ()、wait ()之后，线程就会处于阻塞状态。这个时候需要其他机制将处于阻塞状态的线程唤醒，如 notify ()、notifyAll ()方法。被唤醒的线程不会立即执行 run 方法，会回到就绪阶段，再次等待 CPU 分配资源进入运行状态。</p>
</li>
<li><p><strong>销毁：</strong> 如果线程正常执行完毕或被提前强制终止或出现异常导致结束，那么线程就会被销毁并释放资源。</p>
</li>
</ol>
<h3 id="2-线程的-6-个状态："><a href="#2-线程的-6-个状态：" class="headerlink" title="2. 线程的 6 个状态："></a>2. 线程的 6 个状态：</h3><ul>
<li>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</li>
<li>RUNNABLE: 运行状态，线程被调用了 <code>start()</code> 等待运行的状态。</li>
<li>BLOCKED ：阻塞状态，需要等待锁释放。</li>
<li>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</li>
<li>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li>
<li>TERMINATED：终止状态，表示该线程已经运行完毕。</li>
</ul>
<h3 id="3-阻塞的三种情况：等待阻塞、同步阻塞、其他阻塞"><a href="#3-阻塞的三种情况：等待阻塞、同步阻塞、其他阻塞" class="headerlink" title="3. 阻塞的三种情况：等待阻塞、同步阻塞、其他阻塞"></a>3. 阻塞的三种情况：<strong>等待阻塞</strong>、<strong>同步阻塞</strong>、<strong>其他阻塞</strong></h3><ul>
<li><strong>等待阻塞：</strong> 正在运行中的线程执行 wait ()方法时，JVM 会把该线程放入等待队列中。</li>
<li><strong>同步阻塞：</strong> 运行的线程在获取对象的同步锁时，若该同步锁被其他线程占用，则 JVM 会把该线程放入锁池中。</li>
<li><strong>其他阻塞：</strong> 运行的线程执行 sleep ()、join ()方法，或者发出了 IO 请求时，JVM 会把该线程置为阻塞状态。</li>
</ul>
<h4 id="sleep-和-wait-的区别："><a href="#sleep-和-wait-的区别：" class="headerlink" title="sleep 和 wait 的区别："></a>sleep 和 wait 的区别：</h4><p>sleep 和 wait 的区别在于这两个方法来自不同的类分别是 Thread 和 Object，<strong>sleep 方法没有释放锁，而 wait 方法释放了锁</strong>，使得其他线程可以使用同步控制块或者方法。</p>
<p>sleep 是线程被调用时，占着 cpu 去睡觉，其他线程不能占用 cpu，os 认为该线程正在工作，不会让出系统资源，wait 是进入等待池等待，让出系统资源，其他线程可以占用 cpu，一般 wait 不会加时间限制。</p>
<h3 id="4-线程死亡的三种情况："><a href="#4-线程死亡的三种情况：" class="headerlink" title="4. 线程死亡的三种情况："></a>4. 线程死亡的三种情况：</h3><ul>
<li><p><strong>正常结束：</strong> run ()或 call ()方法执行完成，线程正常结束；</p>
</li>
<li><p><strong>异常结束：</strong> 线程执行过程中抛出一个未捕获的异常导致结束；</p>
</li>
<li><p><strong>强制结束：</strong> 调用线程终止方法强制结束线程：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/k_young1997/article/details/106970529">https://blog.csdn.net/k_young1997/article/details/106970529</a></p>
</blockquote>
<ul>
<li><p><strong>使用退出标志</strong></p>
<p>定义一个<strong>volatile</strong>修饰的 boolean 型的标志位，在线程的 run 方法中根据这个标志位是为 true 还是为 false 来判断是否终止，这种情况多用于 while 循环中。</p>
<p><em>（使用 volatile 目的是保证可见性，一处修改了标志，处处都要去主存读取新的值，而不是使用缓存）</em></p>
</li>
<li><p><strong>Interrupt 方法</strong></p>
<p>使用 interrupt 方法中断线程有两种情况</p>
<ul>
<li><p>线程处于阻塞状态</p>
<p>如使用了 sleep，同步锁的 wait, socket 中的 receiver, accept 等方法时，会使线程处于阻塞状态。当调用线程的 <code>interrupt()</code> 方法时，会抛出 <code>InterruptException</code> 异常。阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后 break 跳出循环状态，从而让我们有机会结束这个线程的执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	threadDemo.start();</span><br><span class="line">	<span class="comment">//阻塞线程</span></span><br><span class="line">	threadDemo.wait();</span><br><span class="line">	<span class="comment">//中断线程</span></span><br><span class="line">	threadDemo.interrupt();</span><br><span class="line">&#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">	<span class="comment">//抛出异常，强制跳出，线程中断</span></span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程未处于阻塞状态</p>
<p>使用 <code>isInterrupted()</code> 判断线程的中断标志来退出循环。当使用 interrupt ()方法时，中断标志就会置 true，和使用自定义的标志来控制循环是一样的道理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadDemo</span> <span class="variable">threadDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDemo</span>();</span><br><span class="line">threadDemo.start();</span><br><span class="line"><span class="comment">//中断线程</span></span><br><span class="line">threadDemo.interrupt();</span><br><span class="line"><span class="comment">//通过while循环不断确认线程是否已经终止</span></span><br><span class="line"><span class="keyword">while</span> (threadDemo.isInterrupted()) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;线程中断&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>stop 方法</strong></p>
<p>调用 stop ()方法，该方法不安全，容易导致死锁</p>
<ul>
<li>调用 stop 方法会立刻终止 run ()方法中剩余的全部任务，包括 catch 或 finally 中的任务，并且抛出 ThreadDeath 异常，因此可能会导致任务执行失败。</li>
<li>调用 stop 方法会立刻释放改线程所持有的所有锁，导致数据无法完成同步，出现数据不一致的问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2、创建线程的三种方式，线程池的好处"><a href="#2、创建线程的三种方式，线程池的好处" class="headerlink" title="2、创建线程的三种方式，线程池的好处"></a>2、创建线程的三种方式，线程池的好处</h2><h3 id="1-创建线程的三种方式：1-个继承，两个实现"><a href="#1-创建线程的三种方式：1-个继承，两个实现" class="headerlink" title="1. 创建线程的三种方式：1 个继承，两个实现"></a>1. 创建线程的三种方式：1 个继承，两个实现</h3><ul>
<li><p>继承 Thread 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">ThreadDemo</span> <span class="variable">threadDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDemo</span>();</span><br><span class="line">        threadDemo.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ThreadDemo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现 Runnable 接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">RunnableDemo</span> <span class="variable">runnableDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runnableDemo).start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不用担心单继承，没有返回值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RunnableDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;RunnableDemo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现 Callable 接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">CallableDemo</span>());</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">        <span class="comment">//get()方法获取返回值</span></span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有返回值也可以抛出异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;CallableDemo&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;return CallableDemo&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li>Thread 只能单继承，Runnable 和 Callable 可以多实现</li>
<li>Thread 和 Runnable 不能得到返回值，Callable 可以获取返回值及捕获异常</li>
</ul>
<h3 id="2-使用线程池的好处"><a href="#2-使用线程池的好处" class="headerlink" title="2. 使用线程池的好处"></a>2. 使用线程池的好处</h3><ul>
<li><strong>降低资源消耗</strong>：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>：当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h2 id="3、如何创建线程池"><a href="#3、如何创建线程池" class="headerlink" title="3、如何创建线程池"></a>3、如何创建线程池</h2><h3 id="1-通过构造方法实现"><a href="#1-通过构造方法实现" class="headerlink" title="1. 通过构造方法实现"></a>1. 通过构造方法实现</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/ThreadPoolExecutor%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95.png" alt="ThreadPoolExecutor构造方法"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span>;</span><br><span class="line"><span class="comment">//核心线程：5；最大线程200；空闲线程存活时间：10；单位：秒；阻塞队列：类型linked，容量10000；线程工程：默认；饱和策略：抛出 RejectedExecutionException来拒绝新任务的处理。</span></span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>,</span><br><span class="line">                <span class="number">200</span>,</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10000</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br></pre></td></tr></table></figure>

<p><strong>ThreadPoolExecutor 7 个参数：</strong></p>
<ol>
<li><p><strong>核心线程数 <code>corePoolSize</code>：</strong> 核心线程数定义了最小可以同时运行的线程数量。</p>
</li>
<li><p><strong>最大线程数 <code>maximumPoolSize</code>：</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</p>
</li>
<li><p><strong>阻塞队列 <code>workQueue</code>：</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p>
</li>
<li><p><strong>存活时间 <code>keepAliveTime</code>：</strong> 当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code> 才会被回收销毁；</p>
</li>
<li><p><strong>存活时间单位 <code>unit</code>：</strong> <code>keepAliveTime</code> 参数的时间单位。</p>
</li>
<li><p><strong>线程工厂 <code>threadFactory</code>：</strong> executor 创建新线程的时候会用到。</p>
</li>
<li><p><strong>饱和策略 <code>handler</code>：</strong> 如果当前同时运行的线程数量达到最大线程数量并且阻塞队列也已经被放满了任务时，会根据饱和策略来处理多余的任务。</p>
<p>常见饱和策略：</p>
<ul>
<li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code> 异常来拒绝新任务的处理。</li>
</ul>
</li>
</ol>
<ul>
<li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 调用执行自己的线程运行任务，也就是直接在调用 <code>execute</code> 方法的线程中运行 (<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。<ul>
<li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li>
<li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</li>
</ul>
</li>
</ul>
<p><strong>线程池运行流程：</strong></p>
<ol>
<li>线程池创建，准备好 core 数量的核心线程，准备接受任务</li>
<li>新的任务进来，用 core 准备好的空闲线程执行。</li>
<li>核心线程 core 满了，就将再进来的任务放入阻塞队列中。空闲的 core 就会自己去阻塞队列获取任务执行</li>
<li>阻塞队列满了，就直接开新线程执行，最大只能开到 max 指定的数量</li>
<li>如果线程数开到了 max 的数量，还有新任务进来，就会使用 RejectedExecutionHandler 指定的拒绝策略拒绝任务</li>
<li>max 都执行完成，有很多空闲。在指定 keepAliveTime 后，会释放 Max-core 数量空闲的线程。最终保持到 core 大小。new LinkedBlockingQueue&lt;&gt;()默认是 integer 的最大值，内存不够</li>
<li>所有的线程创建都是由指定的 factory 创建的</li>
</ol>
<p><strong>总结：核心线程 -&gt; 阻塞队列 -&gt; 新线程 -&gt; 拒绝策略 -&gt; 自动释放空闲核心线程</strong></p>
<h3 id="2-通过-Executor-框架的工具类-Executors-来实现"><a href="#2-通过-Executor-框架的工具类-Executors-来实现" class="headerlink" title="2. 通过 Executor 框架的工具类 Executors 来实现"></a>2. 通过 Executor 框架的工具类 Executors 来实现</h3><p><strong>4 种常见线程池：</strong></p>
<ul>
<li><p><strong>CachedThreadPool</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，</span></span><br><span class="line"><span class="comment"> * 若无可回收，则新建线程。</span></span><br><span class="line"><span class="comment"> * 没有核心线程，所有线程都可以回收。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>FixedThreadPool</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个定长线程池，可控制线程最大并发数，</span></span><br><span class="line"><span class="comment"> * 超出的线程会在队列中等待。</span></span><br><span class="line"><span class="comment"> * 核心线程数和最大线程数相同，固定线程数大小，所有线程都不可以回收。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Executors.newFixedThreadPool(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ScheduledThreadPool</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个定长线程池，支持定时及周期性任务执行。</span></span><br><span class="line"><span class="comment"> * 可以指定多长时间以后执行任务。定时任务线程池。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>SingleThreadExecutor</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，</span></span><br><span class="line"><span class="comment"> * 保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</span></span><br><span class="line"><span class="comment"> * 单线程的线程池，核心和最大线程数都为 1。</span></span><br><span class="line"><span class="comment"> * 后台从队列中取一个执行一个，相当于后台用单线程执行任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4、submit-和-execute-的区别"><a href="#4、submit-和-execute-的区别" class="headerlink" title="4、submit 和 execute 的区别"></a>4、submit 和 execute 的区别</h2><ol>
<li><strong><code>execute()</code> 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li>
<li><strong><code>submit()</code> 方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code> 方法来获取返回值，<code>get()</code> 方法会阻塞当前线程直到任务完成，而使用 <code>get(long timeout，TimeUnit unit)</code> 方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li>
</ol>
<h2 id="5、Java-并发包下常用的类库"><a href="#5、Java-并发包下常用的类库" class="headerlink" title="5、Java 并发包下常用的类库"></a>5、Java 并发包下常用的类库</h2><ul>
<li><p>CountDownLatch</p>
</li>
<li><p>LockSupport</p>
</li>
<li><p>BlockingQueue</p>
</li>
<li><p>Executors</p>
</li>
<li><p>ArrayBlockingQueue</p>
</li>
<li><p>FutureTask</p>
</li>
<li><p>CompletableFuture</p>
</li>
</ul>
<h2 id="6、Nacos、ZooKeeper、Eureka-的选择，各种优缺点"><a href="#6、Nacos、ZooKeeper、Eureka-的选择，各种优缺点" class="headerlink" title="6、Nacos、ZooKeeper、Eureka 的选择，各种优缺点"></a>6、Nacos、ZooKeeper、Eureka 的选择，各种优缺点</h2><p>ZooKeeper 实现了 CP</p>
<p>Eureka 实现了 AP</p>
<p>Nacos 是根据配置实现 CP 和 AP</p>
<h2 id="7、AQS"><a href="#7、AQS" class="headerlink" title="7、AQS"></a>7、AQS</h2><h3 id="1-AQS-核心思想"><a href="#1-AQS-核心思想" class="headerlink" title="1. AQS 核心思想"></a>1. AQS 核心思想</h3><p><strong>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是基于 CLH 锁 （Craig, Landin, and Hagersten locks） 实现的。</strong></p>
<h3 id="2-CLH"><a href="#2-CLH" class="headerlink" title="2. CLH"></a>2. CLH</h3><p>CLH 是指 Craig, Landin, and Hagersten，是一种经典的自旋锁算法，用于解决并发环境下的互斥访问问题。CLH 自旋锁是一种基于链表的软件锁算法，采用了无忙等待的自旋方式，避免了传统自旋锁的缺点。</p>
<p>CLH 自旋锁的核心思想是<strong>使用一个链表来表示所有等待获取锁的线程，链表中的每个节点代表一个竞争线程。每个节点都维护一个标志位，用来表示前一个节点是否已经释放了锁。</strong></p>
<p>CLH 自旋锁的获取和释放过程如下：</p>
<ol>
<li>获取锁：当线程需要获取锁时，它会创建一个新的节点，并将自己加入到链表的末尾。然后它会自旋等待，不断检查前一个节点的标志位，直到前一个节点释放了锁。</li>
<li>释放锁：当线程释放锁时，它会将自己所对应的节点的标志位置为已释放，并将其从链表中移除。这样后续等待的线程就可以通过自旋获取锁。</li>
</ol>
<p>CLH 自旋锁的特点包括：</p>
<ol>
<li>无忙等待：CLH 自旋锁通过自旋等待的方式来获取锁，避免了传统自旋锁在竞争激烈情况下的忙等待问题，减少了对 CPU 的占用，提高了性能。</li>
<li>FIFO 队列：CLH 自旋锁的链表是按照线程请求锁的顺序排队的，保证了公平性，避免了饥饿现象的发生。</li>
<li>缓存友好性：CLH 自旋锁的节点通过自旋等待获取锁，而不是忙等待，这样可以减少对共享变量的频繁访问，提高了缓存的命中率。</li>
</ol>
<p>需要注意的是，CLH 自旋锁在多处理器系统上的性能通常比较好，但在单处理器系统上可能存在性能问题，因为它会导致线程频繁地进行上下文切换。在实际使用时，需要根据具体的环境和需求来选择合适的锁算法。</p>
<p>CLH 锁是对自旋锁的一种改进，是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系），暂时获取不到锁的线程将被加入到该队列中。AQS 将每条请求共享资源的线程封装成一个 CLH 队列锁的一个结点（Node）来实现锁的分配。在 CLH 队列锁中，一个节点表示一个线程，它保存着线程的引用（thread）、当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。</p>
<h3 id="3-什么是钩子方法"><a href="#3-什么是钩子方法" class="headerlink" title="3. 什么是钩子方法"></a>3. 什么是钩子方法</h3><p>钩子方法是一种被声明在抽象类中的方法，一般使用 <code>protected</code> 关键字修饰，它可以是空方法（由子类实现），也可以是默认实现的方法。模板设计模式通过钩子方法控制固定步骤的实现。</p>
<h2 id="8、CAS"><a href="#8、CAS" class="headerlink" title="8、CAS"></a>8、CAS</h2><p>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p>
<p>CAS 操作是原子性的，即在执行期间不会被其他线程中断，从而确保了线程安全。它实际上是利用了现代处理器提供的原子指令（比如 x 86 的 CMPXCHG 指令）来实现的。</p>
<p>CAS 操作由三个参数组成：</p>
<ul>
<li><strong>V</strong>：要更新的变量值 (Var)</li>
<li><strong>E</strong>：预期值 (Expected)</li>
<li><strong>N</strong>：拟写入的新值 (New)</li>
</ul>
<p>它的执行过程如下：</p>
<ol>
<li>检查变量值是否等于预期值。</li>
<li>如果相等，则将该地址上的值更新为新值。</li>
<li>如果不相等，则表示其他线程已经修改了该值，操作失败。</li>
</ol>
<p><strong>举一个简单的例子</strong>：线程 A 要修改变量 i 的值为 6，i 原值为 1（V &#x3D; 1，E&#x3D;1，N&#x3D;6，假设不存在 ABA 问题）。</p>
<ol>
<li>i 与 1 进行比较，如果相等，则说明没被其他线程修改，可以被设置为 6 。</li>
<li>i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。</li>
</ol>
<p>CAS 的优点在于它避免了使用锁带来的线程切换和上下文切换的开销，从而减少了系统开销和提高了并发性能。然而，CAS 也存在一些限制和问题，主要包括：</p>
<p><strong>ABA 问题：如果变量的值在操作过程中被其他线程从预期值变为又变回预期值，CAS 操作可能会误判，无法感知到变量的变化。</strong></p>
<p>ABA 问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。JDK 1.5 以后的 <code>AtomicStampedReference</code> 类就是用来解决 ABA 问题的，其中的 <code>compareAndSet()</code> 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<p>为了解决 CAS 的限制，Java 提供了 Atomic 包下的一系列原子类，如 AtomicInteger、AtomicLong、AtomicReference 等，它们封装了 CAS 操作，提供了更便捷和安全的方式来进行原子操作。</p>
<h2 id="9、BlockingQueue"><a href="#9、BlockingQueue" class="headerlink" title="9、BlockingQueue"></a>9、BlockingQueue</h2><p>阻塞队列</p>
<p>ArrayBlockingQueue 是 Java 中的一个线程安全（线程同步）的固定大小的阻塞队列，它是基于数组实现的。它是在 java. util. concurrent 包下的一个类。</p>
<p>ArrayBlockingQueue 的主要特点有：</p>
<ol>
<li>有界性：ArrayBlockingQueue 的容量是固定的，即在创建队列时必须指定队列的容量大小。</li>
<li>先进先出（FIFO）：ArrayBlockingQueue 严格按照元素的插入顺序进行操作，保证先进来的元素先被获取。</li>
<li>线程安全：ArrayBlockingQueue 使用内部锁（ReentrantLock）实现了线程安全。它对插入和删除操作进行了同步，以确保多线程环境下的并发操作不会出现问题。</li>
<li>阻塞操作：ArrayBlockingQueue 支持阻塞操作，当队列为空时，从队列中获取元素的操作会被阻塞，直到有元素可用；当队列已满时，插入元素的操作会被阻塞，直到队列有空闲位置可用。</li>
<li>支持可选的公平性：可以通过构造函数设置公平性参数，如果设置为 true，则等待时间更长的线程会优先获得锁。</li>
</ol>
<p>使用 ArrayBlockingQueue 可以方便地实现生产者-消费者模式，生产者线程将元素插入队列，消费者线程从队列中获取元素。当队列为空时，消费者线程会被阻塞，直到队列中有元素可用；当队列已满时，生产者线程会被阻塞，直到队列有空闲位置可用。</p>
<p>需要注意的是，在 ArrayBlockingQueue 中，当队列已满时尝试插入元素会导致线程被阻塞，当队列为空时尝试获取元素也会导致线程被阻塞。因此，在使用 ArrayBlockingQueue 时要合理处理阻塞操作可能引发的线程安全和性能问题。</p>
<h2 id="10、lock"><a href="#10、lock" class="headerlink" title="10、lock"></a>10、lock</h2><h3 id="1-锁（Lock）"><a href="#1-锁（Lock）" class="headerlink" title="1. 锁（Lock）"></a>1. 锁（Lock）</h3><p>在并发编程中，锁是用于控制对共享资源的访问的一种同步机制。它用于确保在同一时间内只有一个线程可以访问被锁定的资源，从而保证线程安全。</p>
<ol>
<li><strong>显示锁</strong>（Explicit Lock）：显式锁是由代码明确调用的锁机制。在 Java 中，ReentrantLock 是一个常见的显式锁实现，它提供了显式的 lock () 和 unlock () 方法来控制对临界区的访问。</li>
<li><strong>隐式锁</strong>（Implicit Lock）：隐式锁是由语言或运行时环境自动管理的锁机制。在 Java 中，synchronized 关键字就是一种隐式锁机制，它可以应用于方法或代码块，隐式地在进入和退出临界区时获取和释放锁。</li>
</ol>
<h3 id="2-互斥锁（Mutex-Lock）"><a href="#2-互斥锁（Mutex-Lock）" class="headerlink" title="2. 互斥锁（Mutex Lock）"></a>2. 互斥锁（Mutex Lock）</h3><p>互斥锁是一种特殊类型的锁，用于保护共享资源的互斥访问。当一个线程获取了互斥锁后，其他线程必须等待锁的释放才能访问共享资源。互斥锁提供了排他性，保证同一时间只有一个线程能够持有锁。</p>
<h3 id="3-自旋锁（Spin-Lock）"><a href="#3-自旋锁（Spin-Lock）" class="headerlink" title="3. 自旋锁（Spin Lock）"></a>3. 自旋锁（Spin Lock）</h3><p>自旋锁是一种特殊类型的锁，采用忙等待的方式来实现线程的同步。当一个线程尝试获取自旋锁时，如果锁已经被其他线程占用，该线程会进入忙等待状态，不断循环检查锁是否被释放。自旋锁一般适用于锁的持有时间较短的情况，避免线程切换带来的开销。</p>
<p>总而言之，锁是一种用于实现并发编程中线程同步和对共享资源进行保护的机制。它可以防止多个线程同时修改共享资源，从而确保数据的一致性和线程的安全性。不同类型的锁有不同的特点和适用场景，开发者需要根据具体需求选择合适的锁机制。</p>
<h2 id="11、volatile"><a href="#11、volatile" class="headerlink" title="11、volatile"></a>11、volatile</h2><p>volatile 是 Java 中的关键字，用于修饰变量。它具有以下两个主要的作用：</p>
<ol>
<li><strong>可见性</strong>（Visibility）：使用 volatile 修饰的变量对所有线程可见。当一个线程修改了 volatile 变量的值，该变量的新值会立即被写入主内存，并且其他线程可以立即看到最新的值。这解决了多线程间的可见性问题，避免了使用普通变量时的数据不一致性问题。</li>
<li><strong>禁止指令重排序</strong>（Ordering）：使用 volatile 修饰的变量的读写操作会被插入到内存屏障（Memory Barrier）之前和之后，防止指令重排序优化。这保证了 volatile 变量的读写操作具有所谓的 happens-before 关系，即写操作发生在后续的读操作之前，确保了操作的有序性。</li>
</ol>
<p>需要注意的是，volatile 提供的可见性和禁止指令重排序的保证是有限的，它并不能保证原子性。对于复合操作，如 i++ 的原子性操作，volatile 无法保证线程安全，需要使用其他同步机制（如锁）或者使用原子类（如 AtomicIntegerFieldUpdater）来实现。</p>
<p>使用 volatile 的常见场景包括：</p>
<ol>
<li><strong>标志位</strong>：用于控制并发任务的启动、暂停或停止。</li>
<li><strong>双重检查锁定</strong>（Double-Checked Locking）：用于在延迟初始化对象的情况下，确保多个线程能够正确地获取初始化后的对象。</li>
</ol>
<p>总结来说，volatile 是一种用于保证变量可见性和禁止指令重排序的关键字。它提供了一种简单而轻量的线程同步机制，适用于某些特定的并发场景。然而，对于更复杂的线程同步需求，需要使用更强大的同步机制（如锁）来确保线程安全性。</p>
<h2 id="12、synchronized"><a href="#12、synchronized" class="headerlink" title="12、synchronized"></a>12、synchronized</h2><p>synchronized 是 Java 中的关键字，用于实现线程之间的同步和互斥访问。它可以应用于方法或代码块，用于控制对共享资源的访问，并保证多个线程对共享资源的安全性。</p>
<p>使用 synchronized 的主要作用包括：</p>
<ol>
<li><strong>互斥访问</strong>：当多个线程同时访问同一个被 synchronized 修饰的方法或代码块时，只会有一个线程能够进入临界区，其他线程需要等待。这样可以确保在同一时间内只有一个线程对共享资源进行操作，避免了数据的竞争和不一致性。</li>
<li><strong>可见性和有序性</strong>：除了提供互斥访问之外，synchronized 还提供了对变量的可见性和有序性保证。当一个线程释放 synchronized 的锁时，它会将对共享变量的更新刷新到主内存中，使得其他线程能够立即看到最新的值，并且保证了操作的有序性。</li>
</ol>
<p>使用 synchronized 的方式有两种：</p>
<ol>
<li><strong>同步方法</strong>（Synchronized Method）：使用 synchronized 修饰的方法称为同步方法。当线程调用同步方法时，它会自动获取该方法所属对象（或类）的锁，并在方法执行过程中保持独占。其他线程需要等待锁的释放才能执行相同对象（或类）的同步方法。</li>
<li><strong>同步代码块</strong>（Synchronized Block）：使用 synchronized 修饰的代码块称为同步代码块。它需要指定一个对象作为锁，也称为监视器对象。同一时间只有一个线程可以持有该对象的锁，并执行进入锁定的代码块。其他线程需要等待该锁的释放才能执行相同对象的同步代码块。</li>
</ol>
<p>需要注意的是，synchronized 是一种重量级的锁机制，涉及到线程的上下文切换和内核态的操作。在使用 synchronized 时，应尽量减小同步范围，避免持有锁的时间过长，以提高程序的性能。</p>
<p>总结来说，synchronized 是一种用于实现线程同步和互斥访问的关键字。它能够保证对共享资源的原子性操作、可见性和有序性，并防止多个线程同时修改共享资源。在多线程编程中，使用 synchronized 是一种常见且有效的同步机制。</p>
<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h2 id="1、微服务事务解决方案-2-PC、ttc-等"><a href="#1、微服务事务解决方案-2-PC、ttc-等" class="headerlink" title="1、微服务事务解决方案 2 PC、ttc 等"></a>1、微服务事务解决方案 2 PC、ttc 等</h2><h3 id="1-2-PC"><a href="#1-2-PC" class="headerlink" title="1. 2 PC:"></a>1. 2 PC:</h3><p>2 PC（Two-Phase Commit）是一种常见的分布式事务协议，用于实现多个参与者（Participants）之间的一致性。它通过协调器（Coordinator）和参与者之间的协作来确保在分布式环境中的事务的一致性。<br>2 PC 协议的执行过程分为两个阶段：</p>
<ol>
<li><p><strong>准备阶段</strong>（Prepare Phase）：</p>
<p>在该阶段，协调器向所有参与者发出准备请求。参与者执行事务操作并将准备状态（Prepare）通知协调器。如果参与者成功执行并准备好提交事务，则返回准备就绪状态（Ready to Commit）。如果有任何一个参与者无法准备好提交事务，它将返回无法准备状态（Unable to Prepare）。</p>
</li>
<li><p><strong>提交阶段</strong>（Commit Phase）：</p>
<p>如果所有参与者都返回了准备就绪状态，协调器将发送提交请求给所有参与者。参与者接收到提交请求后，执行事务的最终提交操作，并将提交确认（Commit Acknowledgment）通知协调器。一旦协调器接收到所有参与者的提交确认，它将发出全局提交（Global Commit）的通知。</p>
</li>
</ol>
<p>通过这个两阶段的协作，2 PC 协议实现了分布式事务的提交一致性。但是，2 PC 协议也存在一些缺点：</p>
<ol start="3">
<li><p>阻塞问题：在 2 PC 的执行过程中，参与者在等待协调器的请求时会阻塞，这可能导致整个事务的执行时间较长，并且会增加协调器故障的风险。</p>
</li>
<li><p>单点故障：协调器作为中心化的组件，一旦发生故障，将导致整个协议无法继续执行，从而影响整个分布式事务的一致性。</p>
</li>
<li><p>数据不一致问题：2 PC 协议在网络分区、参与者故障或通信故障等情况下可能导致数据不一致的问题。例如，在准备阶段失败时，已准备好的参与者可能无法回滚之前的操作，导致数据不一致。</p>
</li>
</ol>
<p>鉴于 2 PC 的缺点，一些替代的分布式事务协议也被提出，如 3 PC（Three-Phase Commit）、Paxos、Raft 等，它们针对 2 PC 的一些问题进行了改进和优化。此外，一些基于补偿的事务处理模式（如 Saga 模式）也被广泛应用于大规模微服务架构中。</p>
<h3 id="2-TTC："><a href="#2-TTC：" class="headerlink" title="2. TTC："></a>2. TTC：</h3><p>在微服务架构中，处理分布式事务是一个挑战性的任务。其中，TTC（Transactional Two-Phase Commit）是一种用于解决微服务事务一致性的解决方案之一。<br>TTC 是一种变种的 2 PC（Two-Phase Commit）协议，专门用于处理微服务架构中的分布式事务。它在传统的 2 PC 协议基础上进行了改进，以提高性能和可靠性。<br>TTC 的主要思想是将事务划分为一组子事务（Subtransactions），每个子事务对应于一个微服务。协调者（Coordinator）负责协调所有子事务的一致性。<br>TTC 的执行过程如下：</p>
<ol>
<li><p><strong>准备阶段</strong>（Prepare Phase）：</p>
<p>协调者将准备请求发送给所有子事务。每个子事务执行自身的事务操作，并将准备状态（Prepare）返回给协调者。如果所有子事务都准备好提交事务，则进入下一阶段。否则，如果有任何一个子事务无法准备好，则中止整个事务。</p>
</li>
<li><p><strong>提交阶段</strong>（Commit Phase）：</p>
<p>协调者将提交请求发送给所有准备好的子事务。每个子事务执行自身的事务提交操作，并将确认状态（Commit Acknowledgment）返回给协调者。协调者等待所有子事务的确认，如果所有子事务都成功确认，则整个事务提交成功。如果有任何一个子事务无法确认，则中止整个事务。</p>
</li>
</ol>
<p>通过 TTC 协议，微服务架构中的分布式事务可以实现一致性。相较于传统的 2 PC 协议，TTC 减少了等待时间，并且在部分子事务失败的情况下能够快速中止整个事务，减少了不必要的等待和资源占用。<br>需要注意的是，尽管 TTC 在解决微服务事务一致性方面具有一定的优势，但它仍然可能遭遇网络分区、故障恢复等问题。因此，针对具体的应用场景，可能还需要结合其他技术和策略来提高事务处理的可靠性和性能。</p>
<h2 id="2、CAP、BASE-理论，在项目中的取舍"><a href="#2、CAP、BASE-理论，在项目中的取舍" class="headerlink" title="2、CAP、BASE 理论，在项目中的取舍"></a>2、CAP、BASE 理论，在项目中的取舍</h2><h3 id="1-CAP-定理"><a href="#1-CAP-定理" class="headerlink" title="1. CAP 定理"></a>1. CAP 定理</h3><ul>
<li>一致性</li>
<li>可用性</li>
<li>分区容错性</li>
</ul>
<p>这三个指标不可能同时做到，这个结论就叫做 CAP 定理。</p>
<ol>
<li><strong>分区容错性</strong>（Partition tolerance） ：比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。介于分区状态下，G 1 和 G 2 是两台跨区的服务器，G 1 向 G 2 发送一条消息，G 2 可能无法收到，因为网络总是不可靠的，因此可以认为 P 总是成立的。</li>
<li><strong>可用性</strong>（Availability） ：只要收到用户的请求，服务器就必须给出回应，但此时由于网络问题会导致服务器之间的数据无法做到实时同步，牺牲了一致性，此时满足 AP。</li>
<li><strong>一致性</strong>（Consistency） ：用户 A 访问系统 A，用户 B 访问系统 B，系统 A 和系统 B 保持同步，当用户 A 对系统 A 的 data 做出更改后，用户 B 查询系统 B 的 data 时，需要查询出用户 A 操作后的数据，而同步是要通过网络，网络却又总是不可靠的，所以为确保用户 B 能查询出用户 A 修改的数据，必须在用户 B 查询前将系统 A 的 data 同步到系统 B 上，这样就牺牲了可用性，此时满足 CP。</li>
</ol>
<h3 id="2-BASE-理论"><a href="#2-BASE-理论" class="headerlink" title="2. BASE 理论"></a>2. BASE 理论</h3><p>由于 CAP 中一致性 C 和可用性 A 无法兼得，eBay 的架构师，提出了 BASE 理论，它是通过牺牲数据的强一致性，来获得可用性。它有如下3种特征：</p>
<ol>
<li>基本可用（Basically Available）：分布式系统在出现不可预知故障的时候，允许损失部分可用性，保证核心功能的可用。</li>
<li>软状态（Soft State）：软状态也称为弱状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</li>
<li>最终一致性（Eventually consistent）：最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</li>
</ol>
<p> BASE 理论并没有要求数据的强一致性，而是允许数据在一定的时间段内是不一致的，但在最终某个状态会达到一致。在生产环境中，很多公司，会采用 BASE 理论来实现数据的一致，因为产品的可用性相比强一致性来说，更加重要。比如在电商平台中，当用户对一个订单发起支付时，往往会调用第三方支付平台，比如支付宝支付或者微信支付，调用第三方成功后，第三方并不能及时通知我方系统，在第三方没有通知我方系统的这段时间内，我们给用户的订单状态显示支付中，等到第三方回调之后，我们再将状态改成已支付。虽然订单状态在短期内存在不一致，但是用户却获得了更好的产品体验。</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="1、MySQL存储引擎有哪些，默认的存储引擎是什么，为什么用这个"><a href="#1、MySQL存储引擎有哪些，默认的存储引擎是什么，为什么用这个" class="headerlink" title="1、MySQL存储引擎有哪些，默认的存储引擎是什么，为什么用这个"></a>1、MySQL存储引擎有哪些，默认的存储引擎是什么，为什么用这个</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_48826058/article/details/123690955">https://blog.csdn.net/qq_48826058/article/details/123690955</a></p>
</blockquote>
<h3 id="1-InnoDB存储引擎"><a href="#1-InnoDB存储引擎" class="headerlink" title="1.InnoDB存储引擎"></a>1.InnoDB存储引擎</h3><ul>
<li>事务安全</li>
<li>支持外键</li>
<li>支持全文索引</li>
</ul>
<p><strong>适用场景：需要事务支持、行级锁定对高并发有很好地适应能力，但需要确保查询是通过索引完成、数据更新较为频繁。</strong></p>
<h3 id="2-MyISAM存储引擎"><a href="#2-MyISAM存储引擎" class="headerlink" title="2.MyISAM存储引擎"></a>2.MyISAM存储引擎</h3><ul>
<li>不是事务安全的</li>
<li>不支持外键</li>
<li>表格可以被压缩，且支持全文索引</li>
<li>不支持缓存数据文件</li>
</ul>
<p><strong>适用场景</strong>：<strong>不需要事务支持</strong>、<strong>并发相对较低</strong>、<strong>数据修改相对较少</strong>、<strong>以读为主</strong>、<strong>数据一致性要求不是特别高</strong>。</p>
<h3 id="3-MEMORY存储引擎"><a href="#3-MEMORY存储引擎" class="headerlink" title="3.MEMORY存储引擎"></a>3.MEMORY存储引擎</h3><ul>
<li>把表临时性存放在内存中，数据库重启或崩溃数据就会丢失</li>
<li>默认使用哈希索引</li>
<li>只支持表锁</li>
<li>并发性能较差</li>
<li>不支持text和blob列类型</li>
<li>浪费内存，比如：存储变长字段（varchar）时是按照定长字段（char）的方式进行的。</li>
</ul>
<h3 id="4-MERGE存储引擎"><a href="#4-MERGE存储引擎" class="headerlink" title="4.MERGE存储引擎"></a>4.MERGE存储引擎</h3><ul>
<li>是一组MyISAM表的组合</li>
<li>对MERGE表进行drop操作，这个操作只删除MERGE的定义，对内部的表没有任何影响。</li>
<li>对表的大小有要求，不能是太大的表。</li>
</ul>
<p><strong>适用场景：需要很快的读&#x2F;写速度，对数据安全性要求较低。</strong></p>
<h3 id="5-默认的存储引擎"><a href="#5-默认的存储引擎" class="headerlink" title="5.默认的存储引擎"></a>5.默认的存储引擎</h3><p><strong>mysql-5.1版本之前默认引擎是MyISAM，之后是innoDB</strong></p>
<h3 id="6-MyISAM和InnoDB的区别"><a href="#6-MyISAM和InnoDB的区别" class="headerlink" title="6.MyISAM和InnoDB的区别"></a>6.MyISAM和InnoDB的区别</h3><ol>
<li><p><strong>InnoDB支持事务</strong>，而<strong>MyISAM不支持事务</strong>。</p>
</li>
<li><p><strong>InnoDB支持外键</strong>，而<strong>MyISAM不支持外键</strong>。</p>
</li>
<li><p><strong>InnoDB是行锁</strong>，而<strong>MyISAM是表锁</strong>（每次更新增加删除都会锁住表）。</p>
</li>
<li><p>和MyISAM的索引都是基于b+树，但他们具体实现不一样，<strong>InnoDB的b+树的叶子节点是存放数据的，MyISAM的b+树的叶子节点是存放指针的。</strong></p>
</li>
<li><p><strong>InnoDB是聚簇索引</strong>，必须要有主键，一定会基于主键查询，但是辅助索引就会查询两次。<strong>MyISAM是非聚簇索引</strong>，索引和数据是分离的，索引里保存的是数据地址的指针，主键索引和辅助索引是分开的。</p>
</li>
<li><p>InnoDB不存储表的行数，所以select count( * )的时候会全表查询。而MyISAM会存放表的行数，select count(*）的时候会查的很快。</p>
</li>
</ol>
<h2 id="2、数据库事务特性，事务的隔离级别"><a href="#2、数据库事务特性，事务的隔离级别" class="headerlink" title="2、数据库事务特性，事务的隔离级别"></a>2、数据库事务特性，事务的隔离级别</h2><p>事务就是对数据的一系列操作</p>
<ol>
<li><p><strong>事务的4个特性</strong></p>
<ol>
<li><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>
<li><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性</strong>（<code>Durabilily</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<p><strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</strong></p>
</li>
<li><p><strong>并发事务会产生哪些问题?</strong></p>
<ul>
<li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>
<li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A&#x3D;20，事务 2 也读取 A&#x3D;20，事务 1 修改 A&#x3D;A-1，事务 2 也修改 A&#x3D;A-1，最终结果 A&#x3D;19，事务 1 的修改被丢失。</li>
<li><strong>不可重复读（Unrepeatable read）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>
<li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<p><strong>不可重复读和幻读有什么区别？</strong></p>
<ul>
<li>不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；</li>
<li>幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</li>
</ul>
</li>
<li><p><strong>事务的4个隔离级别</strong></p>
<ul>
<li><strong>READ-UNCOMMITTED(读未提交)</strong> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li><strong>READ-COMMITTED(读已提交)</strong> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
<li><strong>REPEATABLE-READ(可重复读)</strong> ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li><strong>SERIALIZABLE(可串行化)</strong> ： 最高的隔离级别，所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">READ-UNCOMMITTED</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">READ-COMMITTED</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">REPEATABLE-READ</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">SERIALIZABLE</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="3、索引的优缺点，组合索引特性"><a href="#3、索引的优缺点，组合索引特性" class="headerlink" title="3、索引的优缺点，组合索引特性"></a>3、索引的优缺点，组合索引特性</h2><p><strong>优点</strong> ：</p>
<ul>
<li>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
</ul>
<p><strong>缺点</strong> ：</p>
<ul>
<li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>
<li>索引需要使用物理文件存储，也会耗费一定空间。</li>
</ul>
<h2 id="4、外联接和内联接的区别"><a href="#4、外联接和内联接的区别" class="headerlink" title="4、外联接和内联接的区别"></a>4、外联接和内联接的区别</h2><ul>
<li>内连接：指连接结果仅包含符合连接条件的行，参与连接的两个表都应该符合连接条件。</li>
<li>外连接：连接结果不仅包含符合连接条件的行同时也包含自身不符合条件的行。包括左外连接、右外连接和全外连接。<ul>
<li>左外连接：左边表数据行全部保留，右边表保留符合连接条件的行。</li>
<li>右外连接：右边表数据行全部保留，左边表保留符合连接条件的行。</li>
<li>全外连接：左外连接 union 右外连接。</li>
</ul>
</li>
</ul>
<h2 id="5、索引失效场景及原理"><a href="#5、索引失效场景及原理" class="headerlink" title="5、索引失效场景及原理"></a>5、索引失效场景及原理</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7044793268780924935">索引失效场景及原理</a></p>
</blockquote>
<ol>
<li><p>使用函数或表达式：</p>
<p>在 WHERE 子句中对索引列使用函数或表达式会导致索引失效。因为 MySQL 无法预先计算表达式的结果，所以无法使用索引进行查找。<br>例：SELECT * FROM users WHERE YEAR(birthday) &#x3D; 1990;<br>原理：此查询中，YEAR函数作用在索引列birthday上，导致索引失效。</p>
</li>
<li><p>隐式类型转换：</p>
<p>如果查询条件与索引列类型不匹配，MySQL会进行隐式类型转换，可能导致索引失效。<br>例：SELECT * FROM users WHERE age &#x3D; ‘30’;<br>原理：此查询中，假设age字段是整数类型，而查询条件使用了字符串类型，导致类型不匹配。MySQL会尝试将age字段转换为字符串，从而导致索引失效。</p>
</li>
<li><p>不等于（!&#x3D; 或 &lt;&gt;）操作符：</p>
<p>使用不等于操作符会导致索引失效，因为MySQL无法利用索引进行范围查找。<br>例：SELECT * FROM users WHERE age &lt;&gt; 30;<br>原理：此查询中，由于使用了不等于操作符，MySQL无法利用索引进行查找，因此索引失效。</p>
</li>
<li><p>范围查询的多列索引：</p>
<p>对于多列联合索引，如果查询条件中包含范围查询（如BETWEEN、&gt;、&lt; 等），那么在范围查询之后的索引列将失效。<br>例：SELECT * FROM orders WHERE user_id &#x3D; 1 AND order_date &gt; ‘2022-01-01’;<br>原理：假设存在一个多列联合索引(user_id, order_date)，此查询中对order_date进行了范围查询，使得索引列order_date之后的索引失效。</p>
</li>
<li><p>OR 连接的条件：</p>
<p>使用OR连接的条件可能导致索引失效，尤其是在OR条件中涉及多个索引列时。<br>例：SELECT * FROM users WHERE age &#x3D; 30 OR name &#x3D; ‘Alice’;<br>原理：此查询中，由于使用了OR连接，MySQL可能无法同时利用age和name两个索引列进行查找，导致索引失效。</p>
</li>
<li><p>LIKE 查询：</p>
<p>如果在LIKE查询中，通配符（%或_）在字符串的<strong>开头</strong>，将导致索引失效。<br>例：SELECT * FROM users WHERE name LIKE ‘%Alice%’;<br>原理：此查询中，由于通配符在字符串的开头，MySQL无法使用索引进行查找，因此索引失效。</p>
</li>
</ol>
<p>需要注意的是，实际查询优化器会根据数据量、数据分布等因素决定是否使用索引。</p>
<h2 id="6、MySQL-全文索引"><a href="#6、MySQL-全文索引" class="headerlink" title="6、MySQL 全文索引"></a>6、MySQL 全文索引</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7101116456489713700">MySql全文索引</a></p>
<p>全文索引的创建和使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>创建全文索引 </span><br><span class="line"><span class="keyword">CREATE</span> FULLTEXT INDEX <span class="operator">&lt;</span>index_name<span class="operator">&gt;</span> <span class="keyword">on</span> tableName(字段名)   <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tableName <span class="keyword">ADD</span> FULLTEXT[index_name](字段名); <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tableName([....],FULLTEXT KEY[index_name](字段名))`</span><br></pre></td></tr></table></figure>

<p>和常用的<strong>like</strong>不同，全文索引有自己的格式，使用<strong>match</strong>和<strong>against</strong>关键字，如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">match</span>(name) against(<span class="string">&#x27;aaa&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="7、SQL-关键字实际执行顺序"><a href="#7、SQL-关键字实际执行顺序" class="headerlink" title="7、SQL 关键字实际执行顺序"></a>7、SQL 关键字实际执行顺序</h2><p><strong>书写顺序</strong>：SELECT -&gt; FROM -&gt; JOIN -&gt; ON -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; UNION -&gt; ORDER BY -&gt;LIMIT</p>
<p><strong>执行顺序</strong>：FROM -&gt; ON -&gt; JOIN -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT -&gt; UNION -&gt; ORDER BY -&gt;LIMIT</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dz77dz/article/details/115111559">SQL的执行顺序</a></p>
</blockquote>
<ol>
<li><p><strong>FROM</strong>：</p>
<p>确定查询的数据来源，执行笛卡尔积生成基础数据集。</p>
<p>选择from后面跟的表，产生虚拟表1。</p>
</li>
<li><p><strong>ON</strong>（对于JOIN操作）：</p>
<p>应用JOIN条件，从笛卡尔积生成的结果中筛选出匹配的行，形成新的结果集。</p>
<p>ON是JOIN的连接条件，符合连接条件的行会被记录在虚拟表2中。</p>
</li>
<li><p><strong>JOIN</strong>：</p>
<p>根据JOIN类型合并表，如果有多个JOIN链接，会重复执行步骤1~3，直到处理完所有表。</p>
</li>
<li><p><strong>WHERE</strong>：</p>
<p>对上一步产生的结果集应用行级别的筛选条件，进一步减少行数，对虚拟表3进行WHERE条件过滤，符合条件的记录会被插入到虚拟表4中。</p>
</li>
<li><p><strong>GROUP BY</strong>：</p>
<p>根据GROUP BY子句中的列，对虚拟表2中的记录进行分组操作，产生虚拟表5。</p>
</li>
<li><p><strong>HAVING</strong>：</p>
<p>对分组后的数据集应用条件过滤，只保留满足条件的组，对虚拟表5进行HAVING过滤，符合条件的记录会被插入到虚拟表6中。</p>
</li>
<li><p><strong>SELECT</strong>：</p>
<p>SELECT到一步才执行，选择指定的列，插入到虚拟表7中</p>
<p>从处理过的数据集中选择指定的列，执行投影操作。这可能包括对列进行计算、使用别名等。</p>
</li>
<li><p><strong>UNION</strong>：</p>
<p>UNION连接的两个SELECT查询语句，会重复执行步骤1~7，产生两个虚拟表7，UNION会将这些记录合并到虚拟表8中。</p>
</li>
<li><p><strong>ORDER BY</strong>：</p>
<p>将结果集按照指定的列排序。</p>
<p>将虚拟表8中的记录进行排序，虚拟表9。</p>
</li>
<li><p><strong>LIMIT</strong>：</p>
<p>限制返回结果的数量或跳过指定数量的行后开始返回结果。</p>
<p>取出指定行的记录，返回结果集。</p>
</li>
</ol>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="1、JVM-的内存结构"><a href="#1、JVM-的内存结构" class="headerlink" title="1、JVM 的内存结构"></a>1、JVM 的内存结构</h2><p>按线程来讲可以分成两部分，一个是线程独占的，一个是线程共享的</p>
<p>线程共享的有方法区和堆</p>
<ul>
<li><p>堆：包括年轻代与老年代+字符串常量池，年轻代由一个Eden与两个Survivor区。</p>
</li>
<li><p>方法区：方法区是Java虚拟机的模型规范，具体实现是元空间和永久代，永久代是1.7的，1.8以后永久代就被移除了，就变成元空间了，元空间是分布在计算机内存中的，是脱离了Java虚拟机内存的，是独立存在的。</p>
</li>
</ul>
<p>线程独占的是虚拟机栈、本地方法栈、程序计数器</p>
<h2 id="2、JVM常用参数"><a href="#2、JVM常用参数" class="headerlink" title="2、JVM常用参数"></a>2、JVM常用参数</h2><ul>
<li><strong>-Xms</strong>：初始堆内存大小，设定程序启动时占用内存大小，默认物理内存1&#x2F;64  -Xms &#x3D; -XX:InitialHeapSiz</li>
<li><strong>-Xmx</strong>：最大堆内存，设定程序运行期间最大可占用的内存大小。如果程序运行需要占用更多的内存，超出了这个设置值，就会抛出OutOfMemory异常，默认物理内存1&#x2F;4，-Xmx &#x3D; -XX:MaxHeapSize。上图中的-Xms与-Xmx设置的大小一样 6000M</li>
<li><strong>-Xmn</strong>：设置年轻代大小。<strong>整个堆大小&#x3D;年轻代大小 + 年老代大小 + 常量池</strong>。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3&#x2F;8</li>
<li><strong>-Xss：</strong> 设置单个线程栈大小，一般默认512~1024kb。单个线程栈大小跟操作系统和 JDK 版本都有关系，-Xss &#x3D; -XX:ThreadStackSize</li>
<li><strong>-XX:MetaspaceSize</strong> ：元空间大小，元空间本质跟永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间并不在虚拟机中，而是使用本地内存，由操作系统支配。因此，元空间大小仅受本地内存限制。</li>
<li><strong>-XX:+PrintGCDetails</strong> ：打印GC详细日志信息</li>
<li><strong>-XX:SurvivorRatio</strong>：幸存者比例设置，设置年轻代中Eden区与Survivor区的大小比值。设置为8，则两个Survivor区与一个Eden区的比值为2:8，一个Survivor区占整个年轻代的1&#x2F;10</li>
<li><strong>-XX:NewRatio</strong>：新生代比例设置（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为1，则年轻代与年老代所占比值为1：1，年轻代占整个堆栈的1&#x2F;2。</li>
<li><strong>-XX:MaxTenuringThreshold</strong>：进入老年代阈值设置</li>
</ul>
<h2 id="3、JVM常用工具"><a href="#3、JVM常用工具" class="headerlink" title="3、JVM常用工具"></a>3、JVM常用工具</h2><ul>
<li><p><strong>jsp</strong></p>
<p>查看java进程及其相关的信息。</p>
</li>
<li><p><strong>jinfo</strong></p>
<p>主要作用为实时查看和调整虚拟机各项参数。</p>
</li>
<li><p><strong>jmap</strong></p>
<p>查看堆内对象示例的统计信息、ClassLoader 的信息以及finalizer 队列。</p>
<p>也可以生成 java 程序的 dump 文件。</p>
</li>
<li><p><strong>jhat</strong></p>
<p>用来分析jmap生成dump文件的命令。</p>
</li>
<li><p><strong>jstat</strong></p>
<p>查看JVM运行时的状态信息，包括内存状态、垃圾回收等。</p>
</li>
<li><p><strong>jstack</strong></p>
<p>查看JVM线程快照的命令，线程快照是当前JVM线程正在执行的方法堆栈集合。</p>
<p>使用jstack命令可以定位线程出现长时间卡顿的原因，例如死锁，死循环等。</p>
<p>jstack还可以查看程序崩溃时生成的core文件中的stack信息。</p>
</li>
</ul>
<h2 id="4、JVM类加载机制"><a href="#4、JVM类加载机制" class="headerlink" title="4、JVM类加载机制"></a>4、JVM类加载机制</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_48508278/article/details/122929631">https://blog.csdn.net/qq_48508278/article/details/122929631</a></p>
</blockquote>
<p><strong>加载-验证-准备-解析-初始化</strong></p>
<ul>
<li><p>加载</p>
<p>根据类的完整路径查找二进制文件，根据二进制文件创建类对象，存储在堆中。</p>
</li>
<li><p>验证</p>
<p>验证加载内容是否安全，是否会对虚拟机造成异常，验证文件格式，元数据和字节码。</p>
</li>
<li><p>准备</p>
<p>准备给类变量在方法区中进行内存分配，初始化赋零值，给初始值占坑。</p>
</li>
<li><p>解析</p>
<p>把常量池的符号引用转变成直接引用，在内存中通过这个引用找到目标。</p>
</li>
<li><p>初始化</p>
<p>执行Java代码，进行初始化，执行静态代码块，给静态变量赋值。</p>
</li>
</ul>
<h2 id="5、类加载器有哪些"><a href="#5、类加载器有哪些" class="headerlink" title="5、类加载器有哪些"></a>5、类加载器有哪些</h2><ul>
<li>启动类加载器</li>
<li>扩展类加载器</li>
<li>系统类加载器</li>
<li>自定义类加载器</li>
</ul>
<h2 id="6、双亲委派是什么"><a href="#6、双亲委派是什么" class="headerlink" title="6、双亲委派是什么"></a>6、双亲委派是什么</h2><p>当一个类要使用类加载器进行类加载时，会先请求委派给父类加载，当父类还有父类时，会继续往上委派，一直到顶，当父类加载器无法完成这个请求的时候，子类才会尝试去加载</p>
<p><strong>为什么要有双亲委派：认定两个对象同属于一个类型</strong></p>
<h2 id="7、垃圾回收算法常用的有哪些"><a href="#7、垃圾回收算法常用的有哪些" class="headerlink" title="7、垃圾回收算法常用的有哪些"></a>7、垃圾回收算法常用的有哪些</h2><ol>
<li>标记清除</li>
<li>标记复制</li>
<li>标记整理</li>
<li>分代</li>
</ol>
<h2 id="8、Java常见的几种垃圾收集器，Java8默认的垃圾收集器是什么"><a href="#8、Java常见的几种垃圾收集器，Java8默认的垃圾收集器是什么" class="headerlink" title="8、Java常见的几种垃圾收集器，Java8默认的垃圾收集器是什么"></a>8、Java常见的几种垃圾收集器，Java8默认的垃圾收集器是什么</h2><h3 id="1-常见的几种"><a href="#1-常见的几种" class="headerlink" title="1.常见的几种"></a>1.常见的几种</h3><p>7种经典垃圾回收器：Serial、Serial old、ParNew、Parallel Scavenge、Parallel old、CMS、G1</p>
<p>串行回收器：Serial、Serial old</p>
<p>并行回收器：ParNew、Parallel Scavenge、Parallel old</p>
<p>并发回收器：CMS、G1</p>
<h4 id="1-Serial收集器："><a href="#1-Serial收集器：" class="headerlink" title="1.Serial收集器："></a>1.Serial收集器：</h4><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。单线程的收集器，收集垃圾时，必须stop the world，使用复制算法。</p>
<h4 id="2-Serial-Old收集器："><a href="#2-Serial-Old收集器：" class="headerlink" title="2.Serial Old收集器："></a>2.Serial Old收集器：</h4><p>是Serial收集器的老年代版本，单线程收集器，使用标记整理算法。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。</p>
<p>启用命令： -XX:+UseSerialGC -XX:+UseSerialOldGC</p>
<h4 id="3-Parale-Scavenge收集器："><a href="#3-Parale-Scavenge收集器：" class="headerlink" title="3.Parale Scavenge收集器："></a>3.Parale Scavenge收集器：</h4><p>Parallel收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器类似。默认的收集线程数跟cpu核数相同，当然也可以用参数(-XX:ParallelGCThreads)指定收集线程数，但是一般不推荐修改。</p>
<p>Parallel Scavenge收集器关注点是达到一个可控的吞叶量，所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。如果虚拟机总共运行100分钟，其中垃圾花掉1分钟，香叶量就是99%。</p>
<p>新生代采用复制算法，老年代采用标记-整理算法。</p>
<h4 id="4-Parallel-Old收集器："><a href="#4-Parallel-Old收集器：" class="headerlink" title="4.Parallel Old收集器："></a>4.Parallel Old收集器：</h4><p>Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器（JDK8默认的新生代和老年代收集器）。</p>
<p>启用命令 -XX:+UseParallelGC(年轻代),-XX:+UseParallelOldGC(老年代)</p>
<h4 id="5-ParNew收集器："><a href="#5-ParNew收集器：" class="headerlink" title="5.ParNew收集器："></a>5.ParNew收集器：</h4><p>ParNew收集器其实跟Parallel收集器很类似，区别主要在于它可以和CMS收集器配合使用。新生代采用复制算法，老年代采用标记-整理算法。</p>
<h4 id="6-CMS-Concurrent-Mark-Sweep-收集器"><a href="#6-CMS-Concurrent-Mark-Sweep-收集器" class="headerlink" title="6.CMS(Concurrent Mark Sweep) 收集器:"></a>6.CMS(Concurrent Mark Sweep) 收集器:</h4><p>收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用，它是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。整个过程分为5个步骤：初始标记-&gt;并发标记-&gt;重新标记-&gt;并发清理-&gt;并发重置。</p>
<h4 id="7-G1收集器："><a href="#7-G1收集器：" class="headerlink" title="7.G1收集器："></a>7.G1收集器：</h4><p>标记整理算法实现，运作流程主要包括以下:初始标记，并发标记，最终标记，筛选回收，不会产生空间碎片，可以精确地控制停顿。</p>
<h3 id="2-默认：ParallelGC"><a href="#2-默认：ParallelGC" class="headerlink" title="2.默认：ParallelGC"></a>2.默认：ParallelGC</h3><p><strong>1.新生代使用 Parallel Scavenge收集器</strong></p>
<p>使用的算法是基于标记-复制算法实现。收集器的目标是达到一个可控制的吞吐量，如何计算：吞吐量&#x3D;用户代码运行时间&#x2F;（代码运行时间+垃圾收集时间），重点关注一个参数吧 -XX:UserAdaptiveSizePolicy 这个参数激活后，不需要人工的指定新生代大小（-Xmn）、Eden与Surivivor区的比例，晋升老年代对象大小等参数了，虚拟机会根据当前系统运行情况收集性能监控信息动态调整这些参数以提供最合适的停顿时间合或最大的吞吐量。</p>
<p><strong>2.老年带使用的是Parallel Old收集器</strong></p>
<p>是Parallel Scavenge的老年代版本，基于标记-整理算法实现，支持多线程并行收集。他的出现缓解了Parallel Scavenge的尴尬处境，因为Parallel Scavenge和别的优秀的老年代收集器不搭。出现后他俩搭配，才让吞吐量优先的收集器名副其实。</p>
<h2 id="9、JVM-怎么调优"><a href="#9、JVM-怎么调优" class="headerlink" title="9、JVM 怎么调优"></a>9、JVM 怎么调优</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/three-fighter/p/14644152.html">JVM调优总结</a></p>
</blockquote>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="1、Redis-数据类型"><a href="#1、Redis-数据类型" class="headerlink" title="1、Redis 数据类型"></a>1、Redis 数据类型</h2><ul>
<li>string</li>
<li>hash</li>
<li>list</li>
<li>set</li>
<li>zset</li>
</ul>
<h2 id="2、Redis-分布式锁用在哪里，哨兵机制"><a href="#2、Redis-分布式锁用在哪里，哨兵机制" class="headerlink" title="2、Redis 分布式锁用在哪里，哨兵机制"></a>2、Redis 分布式锁用在哪里，哨兵机制</h2><p>当多个线程想要去操作同一个缓存数据时，通过 redis 分布式锁将其锁住，并设置一个到期时间，防止业务异常导致无法解锁。</p>
<p>在查询一个数据的时候，先用 redis 分布式锁将其锁住，然后继续查询，先从 redis 缓存里面查，查不到再从数据库查，并且把查询结果保存到缓存中，然后返回结果，然后删除分布式锁。当下一个操作线程进入时，同样锁住，然后执行业务，可以从缓存中取到值。就是防止缓存穿透。</p>
<h3 id="Redis-哨兵机制"><a href="#Redis-哨兵机制" class="headerlink" title="Redis 哨兵机制"></a>Redis 哨兵机制</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhonglongbo/p/13128955.html">Redis的四种模式，单机、主从、哨兵、集群</a></p>
</blockquote>
<h2 id="3、Redis-的-LUA-脚本有用过吗"><a href="#3、Redis-的-LUA-脚本有用过吗" class="headerlink" title="3、Redis 的 LUA 脚本有用过吗"></a>3、Redis 的 LUA 脚本有用过吗</h2><p>在 Redis 分布式锁用过，在代码中调用 execute 方法，script 参数用执行官方文档上的 LUA 脚本删除分布式锁</p>
<h2 id="4、缓存雪崩、穿透、击穿、数据库一致"><a href="#4、缓存雪崩、穿透、击穿、数据库一致" class="headerlink" title="4、缓存雪崩、穿透、击穿、数据库一致"></a>4、缓存雪崩、穿透、击穿、数据库一致</h2><p>三者出现的根本原因是：Redis 缓存命中率下降，请求直接打到 DB 上了</p>
<p>正常情况下，大量的资源请求都会被 redis 响应，在 redis 得不到响应的小部分请求才会去请求 DB，这样 DB 的压力是非常小的，是可以正常工作的</p>
<p>如果大量的请求在 redis 上得不到响应，那么就会导致这些请求会直接去访问 DB，导致 DB 的压力瞬间变大而卡死或者宕机。</p>
<p>大量的高并发的请求打在 redis 上</p>
<p>这些请求发现 redis 上并没有需要请求的资源，redis 命中率降低</p>
<p>因此这些大量的高并发请求转向 DB（数据库服务器）请求对应的资源</p>
<p>DB 压力瞬间增大，直接将 DB 打垮，进而引发一系列“灾害”</p>
<h3 id="1、缓存穿透："><a href="#1、缓存穿透：" class="headerlink" title="1、缓存穿透："></a>1、缓存穿透：</h3><p>是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</p>
<p><strong>解决：</strong></p>
<p><strong>根本原因（结合上文）就是：请求根本不存在的资源</strong></p>
<ul>
<li><p><strong>对空值进行缓存</strong></p>
<p>类似于上面的例子，虽然数据库中没有 id&#x3D;-9527 的用户的数据，但是在 redis 中对他进行缓存（key&#x3D;-9527，value&#x3D;null），这样当请求到达 redis 的时候就会直接返回一个 null 的值给客户端，避免了大量无法访问的数据直接打在 DB 上。</p>
</li>
<li><p>实时监控</p>
<p>对 redis 进行实时监控，当发现 redis 中的命中率下降的时候进行原因的排查，配合运维人员对访问对象和访问数据进行分析查询，从而进行黑名单的设置限制服务。</p>
</li>
<li><p>使用布隆过滤器</p>
<p>使用 BitMap 作为布隆过滤器，将目前所有可以访问到的资源通过简单的映射关系放入到布隆过滤器中（哈希计算），当一个请求来临的时候先进行布隆过滤器的判断，如果有那么才进行放行，否则就直接拦截。</p>
</li>
<li><p>接口校验</p>
<p>类似于用户权限的拦截，对于 id&#x3D;-3872 这些无效访问就直接拦截，不允许这些请求到达 Redis、DB 上。</p>
</li>
</ul>
<h3 id="2、缓存雪崩："><a href="#2、缓存雪崩：" class="headerlink" title="2、缓存雪崩："></a>2、缓存雪崩：</h3><p>我们可以简单的理解为：由于原有缓存失效，新缓存未到时间 (例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库 CPU 和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</p>
<p><strong>解决：</strong></p>
<p><strong>产生的原因：redis 中大量的 key 集体过期</strong></p>
<ul>
<li><p>将失效时间分散开</p>
<p>通过使用自动生成随机数使得 key 的过期时间是随机的，防止集体过期</p>
</li>
<li><p>使用多级架构</p>
<p>使用 nginx 缓存+redis 缓存+其他缓存，不同层使用不同的缓存，可靠性更强</p>
</li>
<li><p>设置缓存标记</p>
<p>记录缓存数据是否过期，如果过期会触发通知另外的线程在后台去更新实际的 key</p>
</li>
<li><p>使用锁或者队列的方式</p>
<p>如果查不到就加上排它锁，其他请求只能进行等待</p>
</li>
</ul>
<h3 id="3、缓存击穿："><a href="#3、缓存击穿：" class="headerlink" title="3、缓存击穿："></a>3、缓存击穿：</h3><p>某个 key 非常非常热，访问非常的频繁，高并发访问的情况下，当这个 key 在失效（可能 expire 过期了，也可能 LRU 淘汰了）的瞬间，大量的请求进来，这时候就击穿了缓存，直接请求到了数据库，一下子来这么多，数据库肯定受不了，这就叫缓存击穿。某个 key 突然失效，然后这时候高并发来访问这个 key，结果缓存里没有，都跑到 db 了。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
<p><strong>解决：</strong></p>
<p><strong>产生的原因：redis 中的某个热点 key 过期，但是此时有大量的用户访问该过期 key。</strong></p>
<ul>
<li><p>提前对热点数据进行设置</p>
<p>类似于新闻、某博等软件都需要对热点数据进行预先设置在 redis 中</p>
</li>
<li><p>监控数据，适时调整</p>
<p>监控哪些数据是热门数据，实时的调整 key 的过期时长</p>
</li>
<li><p>使用锁机制</p>
<p>只有一个请求可以获取到互斥锁，然后到 DB 中将数据查询并返回到 Redis，之后所有请求就可以从 Redis 中得到响应</p>
</li>
</ul>
<h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><h2 id="1-消息确认"><a href="#1-消息确认" class="headerlink" title="1. 消息确认"></a>1. 消息确认</h2><p>消费者收到的每一条消息都必须进行确认（自动确认和消费者自行确认）。</p>
<p>消费者在声明队列时，可以指定 autoAck 参数，当 autoAck&#x3D;false 时，RabbitMQ 会等待消费者显式发回 ack 信号后才从内存 (和磁盘，如果是持久化消息的话)中移去消息。否则，RabbitMQ 会在队列中消息被消费后立即删除它。</p>
<p>采用消息确认机制后，只要令 autoAck&#x3D;false，消费者就有足够的时间处理消息 (任务)，不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为 RabbitMQ 会一直持有消息直到消费者显式调用 basicAck 为止。</p>
<p>当 autoAck&#x3D;false 时，对于 RabbitMQ 服务器端而言，队列中的消息分成了两部分：一部分是等待投递给消费者的消息；一部分是已经投递给消费者，但是还没有收到消费者 ack 信号的消息。如果服务器端一直没有收到消费者的 ack 信号，并且消费此消息的消费者已经断开连接，则服务器端会安排该消息重新进入队列。</p>
<p>RabbitMQ 不会为未 ack 的消息设置超时时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的消费者连接是否已经断开。这么设计的原因是 RabbitMQ 允许消费者消费一条消息的时间可以很久很久。</p>
<h2 id="2-消息堆积"><a href="#2-消息堆积" class="headerlink" title="2. 消息堆积"></a>2. 消息堆积</h2><ol>
<li><p>消息堆积的后果</p>
<p>新消息无法进入队列、旧消息无法丢失、消息等待消费时间过长以至于超出了业务容许的范围。</p>
</li>
<li><p>消息堆积的原因</p>
<p>生产者突然大量发布消息、消费者来不及消费或消费失败、消费者出现性能瓶颈、消费者直接挂掉了。</p>
</li>
<li><p>如何解决消息堆积</p>
<p>（1）排查生产者，是否突然大量发布消息，限制下</p>
<p>（2）排查消费者，消费性能瓶颈，增加消费者的多线程处理（缩短线程休眠时间等）、部署多个消费者</p>
<p>（3）排查消息队列，可以想办法把消息按顺序的转移到另外一个新的队列，让消费者消费新队列中的消息。</p>
<p>（4）可以通过修改 RabbitMQ 的两个参数来增大消费消息的并发数：</p>
<ol>
<li><p><strong>concurrentConsumers</strong>：对每个 listener 在初始化的时候设置的并发消费者的个数。</p>
</li>
<li><p><strong>prefetchCount</strong>：</p>
<p>每次一次性从 broker 里面取的待消费的消息的个数，prefetchCount 是 BlockingQueueConsumer 内部维护的一个阻塞队列 LinkedBlockingQueue 的大小，其作用就是如果某个消费者队列阻塞，就无法接收新的消息，该消息会发送到其它未阻塞的消费者。</p>
</li>
</ol>
</li>
</ol>
<h2 id="3-消息丢失"><a href="#3-消息丢失" class="headerlink" title="3. 消息丢失"></a>3. 消息丢失</h2><p>消息分别在生产者、消息队列、消费者中丢失：</p>
<h4 id="1-消息在生产者丢失"><a href="#1-消息在生产者丢失" class="headerlink" title="1. 消息在生产者丢失"></a>1. 消息在生产者丢失</h4><p><strong>原因：</strong> 生产者发送消息成功，但 MQ 没收到该消息，一般由网络不稳定造成。</p>
<p>解决方案：发送方采用消息确认机制，当消息成功被 MQ 接收到后，会给生产者发送一个确认消息，表示接收成功。RabbitMQ 发送方确认模式有三种，普通确认、批量确认、异步确认。Spring 整合 RabbitMQ 后只使用了异步监听确认模式。</p>
<h4 id="2-消息在队列中丢失"><a href="#2-消息在队列中丢失" class="headerlink" title="2. 消息在队列中丢失"></a>2. 消息在队列中丢失</h4><p><strong>原因：</strong> 消息发送到 MQ 后，消息还没被消费却在 MQ 中丢失了。比如 MQ 服务器宕机或者未进行持久化就进行了重启。</p>
<p>解决方案：持久化交换机（Exchange）、队列、消息。确保 MQ 服务器异常重启时仍然能从磁盘恢复对应的交换机，队列和消息。然后我们把 MQ 做多台分布式集群，防止出现某一 MQ 服务器挂掉~</p>
<h4 id="3-消息在消费者丢失"><a href="#3-消息在消费者丢失" class="headerlink" title="3. 消息在消费者丢失"></a>3. 消息在消费者丢失</h4><p><strong>原因：</strong> 默认消费者消费消息时，设置的是自动回复 MQ 收到了消息。MQ 会立刻删除自身保存的这条消息，如果消息已经在 MQ 中被删除，但消费者的业务处理出现异常或消费者服务宕机，那么就会导致该消息没有处理成功从而导致消息丢失。</p>
<p><strong>解决方案：</strong> 消费者向 MQ 的回复我们设置成手动回复（配置成手动 ACK）。当消费者出现异常或者服务宕机时，MQ 服务器不会删除该消息，而是会把消息重发给绑定该队列的消费者，如果该队列只绑定了一个消费者，则该消息会一直保持在 MQ 服务器，直到消费者能正常消费为止。</p>
<p>正常业务逻辑应该是本地业务执行成功，手动 ack 这条消息。如果业务执行完毕，手动 ack 的时候恰好服务宕机了，重启……这不是会造成重复消费吗？没错，这就牵扯 mq 的另一个问题了，mq 消息重复消费～</p>
<h2 id="4-重复消费"><a href="#4-重复消费" class="headerlink" title="4. 重复消费"></a>4. 重复消费</h2><ol>
<li><p>场景<br>因消息重发机制会出现消息重复消费的情况</p>
</li>
<li><p>解决方案</p>
</li>
</ol>
<p>（1）幂等操作，同一个操作执行 N 次，结果不变。</p>
<p>（2）若实际业务中用不了幂等，则保存消息 id 到数据库（Redis）中，每次消费前查看消息是否已经被消费过。</p>
<h2 id="5-有序消费"><a href="#5-有序消费" class="headerlink" title="5. 有序消费"></a>5. 有序消费</h2><ol>
<li><p>场景<br>在 work queue 模式下，只有一个队列，但存在多个消费者。多个消费者线程的竞争会导致数据乱序。<br>在简单队列模式下，同样的多个消费者线程也会导致数据乱序。</p>
</li>
<li><p>解决方案<br>使用多个队列，对消息的 id 值做 hash。再对队列数取模（hash 值%队列数），将结果相同的消息压入同一个队列中去，这就保证了一个队列中有且仅有一个消费者。<br>在 MQ 队列后的 Java 代码中（消费方），再为每一个线程加一个内存队列，根据消息的 id 求 hash 值，然后把相同的结果压入同一个内存队列……</p>
</li>
</ol>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="1、线程安全的单例模式"><a href="#1、线程安全的单例模式" class="headerlink" title="1、线程安全的单例模式"></a>1、线程安全的单例模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">SherlockerSun</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2024/07/15/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2024/07/15/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/')">面试总结</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2024/07/15/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=undefined&amp;url=http://example.com/2024/07/15/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/&amp;pic=undefined" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">SherlockerSun</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/Java/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Java<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2024/07/10/hello-world/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Hello World</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">Java 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%8D%A0%E5%87%A0%E4%B8%AA%E5%AD%97%E8%8A%82"><span class="toc-number">1.1.</span> <span class="toc-text">1、Java的基本数据类型有哪些，占几个字节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81String%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83"><span class="toc-number">1.2.</span> <span class="toc-text">2、String类型比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81AOP%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E7%94%A8%E8%BF%87%E5%93%AA%E9%87%8C"><span class="toc-number">1.3.</span> <span class="toc-text">3、AOP是什么，有用过哪里</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81HashMap-%E5%8E%9F%E7%90%86%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%90%97"><span class="toc-number">1.4.</span> <span class="toc-text">4、HashMap 原理，线程安全吗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-HashMap%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.HashMap原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-HashMap%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.HashMap扩容机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-ConcurrentHashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.ConcurrentHashMap底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-ConcurrentHashMap%E5%92%8CHashMap"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.ConcurrentHashMap和HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.5.</span> <span class="toc-text">5.HashMap和HashTable的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-hashtable%E5%92%8Cconcurrenthashmap"><span class="toc-number">1.4.6.</span> <span class="toc-text">6.hashtable和concurrenthashmap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-CountDownLatch"><span class="toc-number">1.4.7.</span> <span class="toc-text">7.CountDownLatch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81ArrayList%E5%92%8CLinkedList%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.</span> <span class="toc-text">5、ArrayList和LinkedList区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81-Transactional%EF%BC%88rollback-Exception-class%EF%BC%89%EF%BC%8C%E6%9C%89%E6%B2%A1%E6%9C%89%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%8C%E4%B8%8D%E5%8A%A0-rollback-%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7"><span class="toc-number">1.6.</span> <span class="toc-text">6、@Transactional（rollback&#x3D;Exception. class），有没有可能会失效，不加 rollback 会怎么样</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81SpringMVC-%E6%B5%81%E7%A8%8B"><span class="toc-number">1.7.</span> <span class="toc-text">7、SpringMVC 流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81BIO%E3%80%81NIO%E3%80%81AIO"><span class="toc-number">1.8.</span> <span class="toc-text">8、BIO、NIO、AIO</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91"><span class="toc-number">2.</span> <span class="toc-text">高并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81"><span class="toc-number">2.1.</span> <span class="toc-text">1、线程的生命周期和状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8C%85%E5%90%AB-5-%E4%B8%AA%E9%98%B6%E6%AE%B5%EF%BC%9A%E6%96%B0%E5%BB%BA%E3%80%81%E5%B0%B1%E7%BB%AA%E3%80%81%E8%BF%90%E8%A1%8C%E3%80%81%E9%98%BB%E5%A1%9E%E3%80%81%E9%94%80%E6%AF%81"><span class="toc-number">2.1.1.</span> <span class="toc-text">1. 线程的生命周期包含 5 个阶段：新建、就绪、运行、阻塞、销毁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E7%9A%84-6-%E4%B8%AA%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="toc-number">2.1.2.</span> <span class="toc-text">2. 线程的 6 个状态：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%98%BB%E5%A1%9E%E7%9A%84%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A%E7%AD%89%E5%BE%85%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E%E3%80%81%E5%85%B6%E4%BB%96%E9%98%BB%E5%A1%9E"><span class="toc-number">2.1.3.</span> <span class="toc-text">3. 阻塞的三种情况：等待阻塞、同步阻塞、其他阻塞</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sleep-%E5%92%8C-wait-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">sleep 和 wait 的区别：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8B%E6%AD%BB%E4%BA%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A"><span class="toc-number">2.1.4.</span> <span class="toc-text">4. 线程死亡的三种情况：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">2.2.</span> <span class="toc-text">2、创建线程的三种方式，线程池的好处</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A1-%E4%B8%AA%E7%BB%A7%E6%89%BF%EF%BC%8C%E4%B8%A4%E4%B8%AA%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.1.</span> <span class="toc-text">1. 创建线程的三种方式：1 个继承，两个实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">2.2.2.</span> <span class="toc-text">2. 使用线程池的好处</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.3.</span> <span class="toc-text">3、如何创建线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.1.</span> <span class="toc-text">1. 通过构造方法实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%9A%E8%BF%87-Executor-%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB-Executors-%E6%9D%A5%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.2.</span> <span class="toc-text">2. 通过 Executor 框架的工具类 Executors 来实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81submit-%E5%92%8C-execute-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.</span> <span class="toc-text">4、submit 和 execute 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Java-%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B1%BB%E5%BA%93"><span class="toc-number">2.5.</span> <span class="toc-text">5、Java 并发包下常用的类库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81Nacos%E3%80%81ZooKeeper%E3%80%81Eureka-%E7%9A%84%E9%80%89%E6%8B%A9%EF%BC%8C%E5%90%84%E7%A7%8D%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.6.</span> <span class="toc-text">6、Nacos、ZooKeeper、Eureka 的选择，各种优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81AQS"><span class="toc-number">2.7.</span> <span class="toc-text">7、AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-AQS-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">2.7.1.</span> <span class="toc-text">1. AQS 核心思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-CLH"><span class="toc-number">2.7.2.</span> <span class="toc-text">2. CLH</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95"><span class="toc-number">2.7.3.</span> <span class="toc-text">3. 什么是钩子方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81CAS"><span class="toc-number">2.8.</span> <span class="toc-text">8、CAS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81BlockingQueue"><span class="toc-number">2.9.</span> <span class="toc-text">9、BlockingQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81lock"><span class="toc-number">2.10.</span> <span class="toc-text">10、lock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%94%81%EF%BC%88Lock%EF%BC%89"><span class="toc-number">2.10.1.</span> <span class="toc-text">1. 锁（Lock）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%88Mutex-Lock%EF%BC%89"><span class="toc-number">2.10.2.</span> <span class="toc-text">2. 互斥锁（Mutex Lock）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%88Spin-Lock%EF%BC%89"><span class="toc-number">2.10.3.</span> <span class="toc-text">3. 自旋锁（Spin Lock）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81volatile"><span class="toc-number">2.11.</span> <span class="toc-text">11、volatile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81synchronized"><span class="toc-number">2.12.</span> <span class="toc-text">12、synchronized</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">3.</span> <span class="toc-text">微服务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-2-PC%E3%80%81ttc-%E7%AD%89"><span class="toc-number">3.1.</span> <span class="toc-text">1、微服务事务解决方案 2 PC、ttc 等</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-PC"><span class="toc-number">3.1.1.</span> <span class="toc-text">1. 2 PC:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-TTC%EF%BC%9A"><span class="toc-number">3.1.2.</span> <span class="toc-text">2. TTC：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81CAP%E3%80%81BASE-%E7%90%86%E8%AE%BA%EF%BC%8C%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%8F%96%E8%88%8D"><span class="toc-number">3.2.</span> <span class="toc-text">2、CAP、BASE 理论，在项目中的取舍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-CAP-%E5%AE%9A%E7%90%86"><span class="toc-number">3.2.1.</span> <span class="toc-text">1. CAP 定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-BASE-%E7%90%86%E8%AE%BA"><span class="toc-number">3.2.2.</span> <span class="toc-text">2. BASE 理论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">4.</span> <span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E9%BB%98%E8%AE%A4%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E8%BF%99%E4%B8%AA"><span class="toc-number">4.1.</span> <span class="toc-text">1、MySQL存储引擎有哪些，默认的存储引擎是什么，为什么用这个</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">4.1.1.</span> <span class="toc-text">1.InnoDB存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-MyISAM%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">4.1.2.</span> <span class="toc-text">2.MyISAM存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-MEMORY%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">4.1.3.</span> <span class="toc-text">3.MEMORY存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-MERGE%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">4.1.4.</span> <span class="toc-text">4.MERGE存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%BB%98%E8%AE%A4%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">4.1.5.</span> <span class="toc-text">5.默认的存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-MyISAM%E5%92%8CInnoDB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.6.</span> <span class="toc-text">6.MyISAM和InnoDB的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7%EF%BC%8C%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">4.2.</span> <span class="toc-text">2、数据库事务特性，事务的隔离级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%8C%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95%E7%89%B9%E6%80%A7"><span class="toc-number">4.3.</span> <span class="toc-text">3、索引的优缺点，组合索引特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%A4%96%E8%81%94%E6%8E%A5%E5%92%8C%E5%86%85%E8%81%94%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.4.</span> <span class="toc-text">4、外联接和内联接的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="toc-number">4.5.</span> <span class="toc-text">5、索引失效场景及原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81MySQL-%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95"><span class="toc-number">4.6.</span> <span class="toc-text">6、MySQL 全文索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81SQL-%E5%85%B3%E9%94%AE%E5%AD%97%E5%AE%9E%E9%99%85%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">4.7.</span> <span class="toc-text">7、SQL 关键字实际执行顺序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM"><span class="toc-number">5.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81JVM-%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.</span> <span class="toc-text">1、JVM 的内存结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81JVM%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0"><span class="toc-number">5.2.</span> <span class="toc-text">2、JVM常用参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81JVM%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">5.3.</span> <span class="toc-text">3、JVM常用工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">5.4.</span> <span class="toc-text">4、JVM类加载机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">5.5.</span> <span class="toc-text">5、类加载器有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">5.6.</span> <span class="toc-text">6、双亲委派是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">5.7.</span> <span class="toc-text">7、垃圾回收算法常用的有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81Java%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%8CJava8%E9%BB%98%E8%AE%A4%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">5.8.</span> <span class="toc-text">8、Java常见的几种垃圾收集器，Java8默认的垃圾收集器是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D"><span class="toc-number">5.8.1.</span> <span class="toc-text">1.常见的几种</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Serial%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9A"><span class="toc-number">5.8.1.1.</span> <span class="toc-text">1.Serial收集器：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Serial-Old%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9A"><span class="toc-number">5.8.1.2.</span> <span class="toc-text">2.Serial Old收集器：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Parale-Scavenge%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9A"><span class="toc-number">5.8.1.3.</span> <span class="toc-text">3.Parale Scavenge收集器：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Parallel-Old%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9A"><span class="toc-number">5.8.1.4.</span> <span class="toc-text">4.Parallel Old收集器：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-ParNew%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9A"><span class="toc-number">5.8.1.5.</span> <span class="toc-text">5.ParNew收集器：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-CMS-Concurrent-Mark-Sweep-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">5.8.1.6.</span> <span class="toc-text">6.CMS(Concurrent Mark Sweep) 收集器:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-G1%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9A"><span class="toc-number">5.8.1.7.</span> <span class="toc-text">7.G1收集器：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%BB%98%E8%AE%A4%EF%BC%9AParallelGC"><span class="toc-number">5.8.2.</span> <span class="toc-text">2.默认：ParallelGC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81JVM-%E6%80%8E%E4%B9%88%E8%B0%83%E4%BC%98"><span class="toc-number">5.9.</span> <span class="toc-text">9、JVM 怎么调优</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis"><span class="toc-number">6.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.1.</span> <span class="toc-text">1、Redis 数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%94%A8%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%8C%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">6.2.</span> <span class="toc-text">2、Redis 分布式锁用在哪里，哨兵机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">6.2.1.</span> <span class="toc-text">Redis 哨兵机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Redis-%E7%9A%84-LUA-%E8%84%9A%E6%9C%AC%E6%9C%89%E7%94%A8%E8%BF%87%E5%90%97"><span class="toc-number">6.3.</span> <span class="toc-text">3、Redis 的 LUA 脚本有用过吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4"><span class="toc-number">6.4.</span> <span class="toc-text">4、缓存雪崩、穿透、击穿、数据库一致</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%9A"><span class="toc-number">6.4.1.</span> <span class="toc-text">1、缓存穿透：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%9A"><span class="toc-number">6.4.2.</span> <span class="toc-text">2、缓存雪崩：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%9A"><span class="toc-number">6.4.3.</span> <span class="toc-text">3、缓存击穿：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MQ"><span class="toc-number">7.</span> <span class="toc-text">MQ</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4"><span class="toc-number">7.1.</span> <span class="toc-text">1. 消息确认</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF"><span class="toc-number">7.2.</span> <span class="toc-text">2. 消息堆积</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1"><span class="toc-number">7.3.</span> <span class="toc-text">3. 消息丢失</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%B6%88%E6%81%AF%E5%9C%A8%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%A2%E5%A4%B1"><span class="toc-number">7.3.0.1.</span> <span class="toc-text">1. 消息在生产者丢失</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B6%88%E6%81%AF%E5%9C%A8%E9%98%9F%E5%88%97%E4%B8%AD%E4%B8%A2%E5%A4%B1"><span class="toc-number">7.3.0.2.</span> <span class="toc-text">2. 消息在队列中丢失</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%B6%88%E6%81%AF%E5%9C%A8%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%A2%E5%A4%B1"><span class="toc-number">7.3.0.3.</span> <span class="toc-text">3. 消息在消费者丢失</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9"><span class="toc-number">7.4.</span> <span class="toc-text">4. 重复消费</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%9C%89%E5%BA%8F%E6%B6%88%E8%B4%B9"><span class="toc-number">7.5.</span> <span class="toc-text">5. 有序消费</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.1.</span> <span class="toc-text">1、线程安全的单例模式</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/15/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" title="面试总结">面试总结</a><time datetime="2024-07-15T08:17:40.000Z" title="发表于 2024-07-15 16:17:40">2024-07-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/10/hello-world/" title="Hello World">Hello World</a><time datetime="2024-07-10T01:04:06.339Z" title="发表于 2024-07-10 09:04:06">2024-07-10</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="SherlockerSun" target="_blank">SherlockerSun</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Java/" style="font-size: 0.88rem;">Java<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 SherlockerSun 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script async src="//at.alicdn.com/t/c/font_4615842_imk1ubsph1.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>